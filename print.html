<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>i3wm 用户说明书</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="介绍.html">介绍</a></li><li class="chapter-item expanded "><a href="默认按键绑定.html"><strong aria-hidden="true">1.</strong> 默认按键绑定</a></li><li class="chapter-item expanded "><a href="使用i3/使用i3.html"><strong aria-hidden="true">2.</strong> 使用 i3</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="使用i3/打开终端和移动焦点.html"><strong aria-hidden="true">2.1.</strong> 打开终端和移动焦点</a></li><li class="chapter-item expanded "><a href="使用i3/改变容器布局.html"><strong aria-hidden="true">2.2.</strong> 改变容器布局</a></li><li class="chapter-item expanded "><a href="使用i3/为窗口切换全屏模式.html"><strong aria-hidden="true">2.3.</strong> 为窗口切换全屏模式</a></li><li class="chapter-item expanded "><a href="使用i3/打开其他应用.html"><strong aria-hidden="true">2.4.</strong> 打开其他应用</a></li><li class="chapter-item expanded "><a href="使用i3/关闭窗口.html"><strong aria-hidden="true">2.5.</strong> 关闭窗口</a></li><li class="chapter-item expanded "><a href="使用i3/使用工作区.html"><strong aria-hidden="true">2.6.</strong> 使用工作区</a></li><li class="chapter-item expanded "><a href="使用i3/移动窗口到工作区.html"><strong aria-hidden="true">2.7.</strong> 移动窗口到工作区</a></li><li class="chapter-item expanded "><a href="使用i3/调整大小.html"><strong aria-hidden="true">2.8.</strong> 调整大小</a></li><li class="chapter-item expanded "><a href="使用i3/原地重启i3.html"><strong aria-hidden="true">2.9.</strong> 原地重启 i3</a></li><li class="chapter-item expanded "><a href="使用i3/退出i3.html"><strong aria-hidden="true">2.10.</strong> 退出 i3</a></li><li class="chapter-item expanded "><a href="使用i3/浮动模式.html"><strong aria-hidden="true">2.11.</strong> 浮动模式</a></li></ol></li><li class="chapter-item expanded "><a href="树/树.html"><strong aria-hidden="true">3.</strong> 树</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="树/由容器构成的树.html"><strong aria-hidden="true">3.1.</strong> 由容器构成的树</a></li><li class="chapter-item expanded "><a href="树/方向与切分容器.html"><strong aria-hidden="true">3.2.</strong> 方向与切分容器</a></li><li class="chapter-item expanded "><a href="树/聚焦父容器.html"><strong aria-hidden="true">3.3.</strong> 聚焦父容器</a></li><li class="chapter-item expanded "><a href="树/隐式容器.html"><strong aria-hidden="true">3.4.</strong> 隐式容器</a></li></ol></li><li class="chapter-item expanded "><a href="配置i3/配置i3.html"><strong aria-hidden="true">4.</strong> 配置 i3</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="配置i3/注释.html"><strong aria-hidden="true">4.1.</strong> 注释</a></li><li class="chapter-item expanded "><a href="配置i3/字体.html"><strong aria-hidden="true">4.2.</strong> 字体</a></li><li class="chapter-item expanded "><a href="配置i3/键盘绑定.html"><strong aria-hidden="true">4.3.</strong> 键盘绑定</a></li><li class="chapter-item expanded "><a href="配置i3/鼠标绑定.html"><strong aria-hidden="true">4.4.</strong> 鼠标绑定</a></li><li class="chapter-item expanded "><a href="配置i3/绑定模式.html"><strong aria-hidden="true">4.5.</strong> 绑定模式</a></li><li class="chapter-item expanded "><a href="配置i3/浮动修饰键.html"><strong aria-hidden="true">4.6.</strong> 浮动修饰键</a></li><li class="chapter-item expanded "><a href="配置i3/限制浮动窗口大小.html"><strong aria-hidden="true">4.7.</strong> 限制浮动窗口大小</a></li><li class="chapter-item expanded "><a href="配置i3/新工作区方向.html"><strong aria-hidden="true">4.8.</strong> 新工作区方向</a></li><li class="chapter-item expanded "><a href="配置i3/新工作区容器布局模式.html"><strong aria-hidden="true">4.9.</strong> 新工作区容器布局模式</a></li><li class="chapter-item expanded "><a href="配置i3/窗口标题对齐.html"><strong aria-hidden="true">4.10.</strong> 窗口标题对齐</a></li><li class="chapter-item expanded "><a href="配置i3/新窗口默认边框样式.html"><strong aria-hidden="true">4.11.</strong> 新窗口默认边框样式</a></li><li class="chapter-item expanded "><a href="配置i3/靠近屏幕边缘隐藏边框.html"><strong aria-hidden="true">4.12.</strong> 靠近屏幕边缘隐藏边框</a></li><li class="chapter-item expanded "><a href="配置i3/针对窗口专用命令（for_window）.html"><strong aria-hidden="true">4.13.</strong> 针对窗口专用命令（for_window）</a></li><li class="chapter-item expanded "><a href="配置i3/打开窗口不聚焦.html"><strong aria-hidden="true">4.14.</strong> 打开窗口不聚焦</a></li><li class="chapter-item expanded "><a href="配置i3/变量.html"><strong aria-hidden="true">4.15.</strong> 变量</a></li><li class="chapter-item expanded "><a href="配置i3/X资源.html"><strong aria-hidden="true">4.16.</strong> X 资源</a></li><li class="chapter-item expanded "><a href="配置i3/自动将客户端放到指定工作区.html"><strong aria-hidden="true">4.17.</strong> 自动将客户端放到指定工作区</a></li><li class="chapter-item expanded "><a href="配置i3/在i3启动时自动运行应用.html"><strong aria-hidden="true">4.18.</strong> 在 i3 启动时自动运行应用</a></li><li class="chapter-item expanded "><a href="配置i3/自动将工作区放到指定显示屏.html"><strong aria-hidden="true">4.19.</strong> 自动将工作区放到指定显示屏</a></li><li class="chapter-item expanded "><a href="配置i3/改变颜色.html"><strong aria-hidden="true">4.20.</strong> 改变颜色</a></li><li class="chapter-item expanded "><a href="配置i3/进程通信.html"><strong aria-hidden="true">4.21.</strong> 进程通信</a></li><li class="chapter-item expanded "><a href="配置i3/焦点跟随鼠标.html"><strong aria-hidden="true">4.22.</strong> 焦点跟随鼠标</a></li><li class="chapter-item expanded "><a href="配置i3/鼠标活动.html"><strong aria-hidden="true">4.23.</strong> 鼠标活动</a></li><li class="chapter-item expanded "><a href="配置i3/全屏模式下的弹出窗口.html"><strong aria-hidden="true">4.24.</strong> 全屏模式下的弹出窗口</a></li><li class="chapter-item expanded "><a href="配置i3/焦点环绕.html"><strong aria-hidden="true">4.25.</strong> 焦点环绕</a></li><li class="chapter-item expanded "><a href="配置i3/强行多荧幕.html"><strong aria-hidden="true">4.26.</strong> 强行多荧幕</a></li><li class="chapter-item expanded "><a href="配置i3/当切换当前工作区时自动来回切换.html"><strong aria-hidden="true">4.27.</strong> 当切换当前工作区时自动来回切换</a></li><li class="chapter-item expanded "><a href="配置i3/延迟工作区变化紧急提示重置.html"><strong aria-hidden="true">4.28.</strong> 延迟工作区变化紧急提示重置</a></li><li class="chapter-item expanded "><a href="配置i3/聚焦窗口活动.html"><strong aria-hidden="true">4.29.</strong> 聚焦窗口活动</a></li><li class="chapter-item expanded "><a href="配置i3/在窗口装饰绘制标记.html"><strong aria-hidden="true">4.30.</strong> 在窗口装饰绘制标记</a></li><li class="chapter-item expanded "><a href="配置i3/连续行.html"><strong aria-hidden="true">4.31.</strong> 连续行</a></li></ol></li><li class="chapter-item expanded "><a href="配置i3bar/.md.html"><strong aria-hidden="true">5.</strong> 配置 i3bar</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="配置i3bar/i3bar命令.html"><strong aria-hidden="true">5.1.</strong> i3bar 命令</a></li><li class="chapter-item expanded "><a href="配置i3bar/状态栏命令.html"><strong aria-hidden="true">5.2.</strong> 状态栏命令</a></li><li class="chapter-item expanded "><a href="配置i3bar/显示模式.html"><strong aria-hidden="true">5.3.</strong> 显示模式</a></li><li class="chapter-item expanded "><a href="配置i3bar/鼠标按键命令.html"><strong aria-hidden="true">5.4.</strong> 鼠标按键命令</a></li><li class="chapter-item expanded "><a href="配置i3bar/Bar编号.html"><strong aria-hidden="true">5.5.</strong> Bar 编号</a></li><li class="chapter-item expanded "><a href="配置i3bar/位置.html"><strong aria-hidden="true">5.6.</strong> 位置</a></li><li class="chapter-item expanded "><a href="配置i3bar/输出.html"><strong aria-hidden="true">5.7.</strong> 输出</a></li><li class="chapter-item expanded "><a href="配置i3bar/托盘输出.html"><strong aria-hidden="true">5.8.</strong> 托盘输出</a></li><li class="chapter-item expanded "><a href="配置i3bar/托盘内边距.html"><strong aria-hidden="true">5.9.</strong> 托盘内边距</a></li><li class="chapter-item expanded "><a href="配置i3bar/字体.html"><strong aria-hidden="true">5.10.</strong> 字体</a></li><li class="chapter-item expanded "><a href="配置i3bar/自定义分隔符.html"><strong aria-hidden="true">5.11.</strong> 自定义分隔符</a></li><li class="chapter-item expanded "><a href="配置i3bar/工作区按钮.html"><strong aria-hidden="true">5.12.</strong> 工作区按钮</a></li><li class="chapter-item expanded "><a href="配置i3bar/工作区按钮最小宽度.html"><strong aria-hidden="true">5.13.</strong> 工作区按钮最小宽度</a></li><li class="chapter-item expanded "><a href="配置i3bar/去除工作区数字和名字.html"><strong aria-hidden="true">5.14.</strong> 去除工作区数字和名字</a></li><li class="chapter-item expanded "><a href="配置i3bar/绑定模式指示器.html"><strong aria-hidden="true">5.15.</strong> 绑定模式指示器</a></li><li class="chapter-item expanded "><a href="配置i3bar/颜色.html"><strong aria-hidden="true">5.16.</strong> 颜色</a></li><li class="chapter-item expanded "><a href="配置i3bar/透明度.html"><strong aria-hidden="true">5.17.</strong> 透明度</a></li></ol></li><li class="chapter-item expanded "><a href="命令列表/命令列表.html"><strong aria-hidden="true">6.</strong> 命令列表</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="命令列表/运行应用（exec）.html"><strong aria-hidden="true">6.1.</strong> 运行应用（exec）</a></li><li class="chapter-item expanded "><a href="命令列表/切分容器.html"><strong aria-hidden="true">6.2.</strong> 切分容器</a></li><li class="chapter-item expanded "><a href="命令列表/操纵布局.html"><strong aria-hidden="true">6.3.</strong> 操纵布局</a></li><li class="chapter-item expanded "><a href="命令列表/聚焦容器.html"><strong aria-hidden="true">6.4.</strong> 聚焦容器</a></li><li class="chapter-item expanded "><a href="命令列表/移动容器.html"><strong aria-hidden="true">6.5.</strong> 移动容器</a></li><li class="chapter-item expanded "><a href="命令列表/交换容器.html"><strong aria-hidden="true">6.6.</strong> 交换容器</a></li><li class="chapter-item expanded "><a href="命令列表/固定浮动窗口.html"><strong aria-hidden="true">6.7.</strong> 固定浮动窗口</a></li><li class="chapter-item expanded "><a href="命令列表/切换（已命名）工作区和移动至新工作区.html"><strong aria-hidden="true">6.8.</strong> 切换（已命名）工作区和移动至新工作区</a></li><li class="chapter-item expanded "><a href="命令列表/移动工作区到另一不同屏幕.html"><strong aria-hidden="true">6.9.</strong> 移动工作区到另一不同屏幕</a></li><li class="chapter-item expanded "><a href="命令列表/移动容器或工作区到RandR输出.html"><strong aria-hidden="true">6.10.</strong> 移动容器或工作区到 RandR 输出</a></li><li class="chapter-item expanded "><a href="命令列表/移动容器和窗口到标记区.html"><strong aria-hidden="true">6.11.</strong> 移动容器和窗口到标记区</a></li><li class="chapter-item expanded "><a href="命令列表/改变窗口和容器大小.html"><strong aria-hidden="true">6.12.</strong> 改变窗口和容器大小</a></li><li class="chapter-item expanded "><a href="命令列表/跳转到特定窗口.html"><strong aria-hidden="true">6.13.</strong> 跳转到特定窗口</a></li><li class="chapter-item expanded "><a href="命令列表/类似VIM的标记（mark和goto）.html"><strong aria-hidden="true">6.14.</strong> 类似 VIM 的标记（mark 和 goto）</a></li><li class="chapter-item expanded "><a href="命令列表/窗口标题格式.html"><strong aria-hidden="true">6.15.</strong> 窗口标题格式</a></li><li class="chapter-item expanded "><a href="命令列表/改变边框样式.html"><strong aria-hidden="true">6.16.</strong> 改变边框样式</a></li><li class="chapter-item expanded "><a href="命令列表/启用共享内存日志.html"><strong aria-hidden="true">6.17.</strong> 启用共享内存日志</a></li><li class="chapter-item expanded "><a href="命令列表/启用调试日志.html"><strong aria-hidden="true">6.18.</strong> 启用调试日志</a></li><li class="chapter-item expanded "><a href="命令列表/重载重启和退出.html"><strong aria-hidden="true">6.19.</strong> 重载重启和退出</a></li><li class="chapter-item expanded "><a href="命令列表/Scratchpad.html"><strong aria-hidden="true">6.20.</strong> Scratchpad</a></li><li class="chapter-item expanded "><a href="命令列表/Nop.html"><strong aria-hidden="true">6.21.</strong> Nop</a></li><li class="chapter-item expanded "><a href="命令列表/i3bar控制.html"><strong aria-hidden="true">6.22.</strong> i3bar 控制</a></li></ol></li><li class="chapter-item expanded "><a href="多显示器/多显示器.html"><strong aria-hidden="true">7.</strong> 多显示器</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="多显示器/配置显示器.html"><strong aria-hidden="true">7.1.</strong> 配置显示器</a></li><li class="chapter-item expanded "><a href="多显示器/多显示器环境下的有趣设置.html"><strong aria-hidden="true">7.2.</strong> 多显示器环境下的有趣设置</a></li></ol></li><li class="chapter-item expanded "><a href="i3和你的其他软件/i3和你的其他软件.html"><strong aria-hidden="true">8.</strong> i3 和你的其他软件</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="i3和你的其他软件/显示状态栏.html"><strong aria-hidden="true">8.1.</strong> 显示状态栏</a></li><li class="chapter-item expanded "><a href="i3和你的其他软件/做展示（多显示器）.html"><strong aria-hidden="true">8.2.</strong> 做展示（多显示器）</a></li><li class="chapter-item expanded "><a href="i3和你的其他软件/高分辨率（HIDPI）.html"><strong aria-hidden="true">8.3.</strong> 高分辨率（HIDPI）</a></li></ol></li><li class="chapter-item expanded "><a href="贡献者.html">贡献者</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">i3wm 用户说明书</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="介绍"><a class="header" href="#介绍">介绍</a></h1>
<h2 id="缘起"><a class="header" href="#缘起">缘起</a></h2>
<p>自从写了篇配置 i3wm 的教程，我的博客访问量激增，看来有蛮多中文用户需要中文的配置文档，正好翻译一本英文书籍是我的人生清单之一（翻译英文文档应该也算？），于是开了这个新坑。</p>
<h2 id="地址"><a class="header" href="#地址">地址</a></h2>
<p>配置文档上游在：<a href="https://github.com/i3/i3.github.io/blob/master/_docs/userguide">https://github.com/i3/i3.github.io/blob/master/_docs/userguide</a></p>
<p>项目地址：<a href="https://github.com/zjuyk/i3wm-userguide-zh">https://github.com/zjuyk/i3wm-userguide-zh</a></p>
<p>构建工具：<a href="https://github.com/zjuyk/i3wm-userguide-zh">https://github.com/rust-lang/mdBook</a></p>
<p>我的翻译水平还有待锻炼，里面一些地方可能不太信达雅，欢迎 PR 修改</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="默认按键绑定"><a class="header" href="#默认按键绑定">默认按键绑定</a></h1>
<p>对于嫌太长不愿意看的用户，这里有一份默认按键绑定的概览：</p>
<p>与 $mod（Alt）相关的按键：</p>
<p><img src="./keyboard-layer1.png" alt="" /></p>
<p>与 Shift+$mod 相关的按键：</p>
<p><img src="./keyboard-layer2.png" alt="" /></p>
<p>红色按键是默认需要按下的前导键，蓝色是后需要按下的自定义键。</p>
<p>当你没有配置文件运行 i3wm 时，i3-config-wizard 会帮你生成一份与上面按键位置相同的配置文件，不管你是用的是什么键盘布局。
如果你更想要一份和上面按键一致的的配置文件，那么拒绝 i3-config-wizard 的自动生成然后在 <code>/etc/i3/config</code> 的基础上自定义。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用-i3"><a class="header" href="#使用-i3">使用 i3</a></h1>
<p>在本指南中，我们使用关键字 <code>$mod</code> 指代配置好的修饰符键。默认情况下，它指的是 Alt 键（<code>Mod1</code>），而一个流行的备选按键是 Windows 键（<code>Mod4</code>），使用后者可在很大程度上防止与应用程序定义的快捷方式发生冲突。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="打开终端和移动焦点"><a class="header" href="#打开终端和移动焦点">打开终端和移动焦点</a></h1>
<p>打开新终端是一个非常基本的操作。默认情况下，这个操作的按键绑定是 <code>$mod + Enter</code>，即默认配置中的 Alt + Enter（<code>Mod1 + Enter</code>）。按下 <code>$mod + Enter</code> 打开一个新终端，它将填满屏幕上的整个可用空间。</p>
<p><img src="%E4%BD%BF%E7%94%A8i3/./single_terminal.png" alt="" /></p>
<p>如果此时打开另一个终端，i3 会将其放置在当前终端的旁边，并将屏幕大小分成两半。i3 会取决显示器的设置，将创建的窗口放在现有窗口的旁边（宽屏显示器）或其下方（旋转显示器）。</p>
<p><img src="%E4%BD%BF%E7%94%A8i3/./two_terminals.png" alt="" /></p>
<p>要在两个终端之间移动焦点，可以使用你可能从 <code>vi</code> 编辑器那儿知道的方向快捷键。然而，在 i3 中，这类快捷键将使用八基本键（也称导位键，即 <code>A</code>、<code>S</code>、<code>D</code>、<code>F</code> 和 <code>J</code>、<code>K</code>、<code>L</code>、<code>;</code> 这一排八个按键 —— 译者注；在 <code>vi</code> 中，为了和大多数键盘布局兼容，这些快捷键向左移了一位）。因此，<code>$mod + j</code> 是往左，<code>$mod + k</code> 是往下，<code>$mod + l</code> 是往上而 <code>$mod + ;</code> 是往右。所以，要在终端间切换，请使用 <code>$mod + k</code> 或 <code>$mod + l</code>。当然，箭头方向键也是可以使用的。</p>
<p>现在，工作区（它包含两个终端）已经在特定方向上被拆分了（默认为水平）。就像工作区一样，每个窗口都可以再次被水平或垂直地拆分。“窗口”这个术语是指实际包含了 X11 窗口（如终端或浏览器）的容器，“拆分容器”则表示包含了一个或多个窗口的容器。</p>
<p>TODO：“树”的图片</p>
<p>要垂直拆分一个窗口，请在创建新窗口前按下 <code>$mod + v</code>。要水平拆分则按下 <code>$mod + h</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="改变容器布局"><a class="header" href="#改变容器布局">改变容器布局</a></h1>
<p>拆分容器可以拥有以下布局之一：</p>
<p><code>splith/splitv</code>（水平拆分/垂直拆分）：</p>
<p>控制窗口的大小，使每个窗口在容器中获得相等的空间。 splith 水平分布窗口（窗口彼此相邻）， splitv 垂直分布窗口（窗口彼此重叠）。</p>
<p><code>stacking</code>（堆叠式）：</p>
<p>只显示容器里聚焦的窗口。你可以在容器的顶部看到一个窗口列表。</p>
<p><code>tabbed</code>（标签化）：</p>
<p>原理和 <code>stacking</code> 相同，但是顶部的窗口列表只有一条垂直分割的行。</p>
<p>要切换模式，请按下 <code>$mod + e</code> 使用 splith/splitv（重复按下可在两者间切换），按下 <code>$mod + s</code> 使用 stacking，按下 <code>$mod + w</code> 使用 tabbed。</p>
<p><img src="%E4%BD%BF%E7%94%A8i3/./modes.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="为窗口切换全屏模式"><a class="header" href="#为窗口切换全屏模式">为窗口切换全屏模式</a></h1>
<p>要以全屏模式显示窗口或再次退出全屏模式，请按下 <code>$mod + f</code>。</p>
<p>i3 中还有一个全局全屏模式，该模式下，客户端将跨越所有可用的输出（命令是 <code>fullscrenn toggle global</code>）。（如果有多个显示器，该模式会将所有显示器看作一个，将窗口跨越多个显示器全屏显示 —— 译者注）</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="打开其他应用"><a class="header" href="#打开其他应用">打开其他应用</a></h1>
<p>除了从终端打开应用程序外，还可以使用方便快捷的 <code>dmenu</code>，默认情况下按下 <code>$mod + d</code> 即可打开它。只需输入想打开的应用程序的名称（或者名称中的几个字）。相应的应用程序必须在 <code>$PATH</code> 路径中才有用。</p>
<p>此外，如果有经常打开的应用程序，可以创建一个绑定按键来直接启动它。详情请参阅 <a href="https://zjuyk.site/i3wm-userguide-zh/%E9%85%8D%E7%BD%AEi3/%E9%85%8D%E7%BD%AEi3.html">配置</a> 部分。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="关闭窗口"><a class="header" href="#关闭窗口">关闭窗口</a></h1>
<p>如果应用程序不提供关闭窗口的机制（大多数应用程序都提供菜单选项、Esc 键或像 <code>Control + w</code> 之类的快捷键来关闭窗口），可以按下 <code>$mod + Shift + q</code> 杀死窗口。支持 WM_DELETE 协议的应用程序会正确关闭自己（保存所有修改并进行其他清理工作）。否则 X 服务器将杀死窗口，后续行为取决于应用程序。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用工作区"><a class="header" href="#使用工作区">使用工作区</a></h1>
<p>工作区是一种将一系列窗口分类的简单方法。如底栏左边所示，默认情况下处于第一工作区。要切换到另一个工作区，请按下 <code>$mod + num</code> 键，<code>num</code> 是想使用的工作区的编号。如果工作区还不存在，则会创建它。</p>
<p>一种常见的范例是，将 Web 浏览器放在一个工作区，通信应用程序（<code>mutt</code>、<code>irssi</code> 等）放在另一个工作区，工作的应用程序放在第三个工作区。当然，没有必要非遵循这种方式不可。</p>
<p>如果有多个屏幕，启动时将会在每个屏幕上创建一个工作区。如果打开一个新的工作区，它将绑定到你创建它的屏幕上。当你切换到位于另一个屏幕的工作区时，i3 会将焦点设置到那块屏幕上。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="移动窗口到工作区"><a class="header" href="#移动窗口到工作区">移动窗口到工作区</a></h1>
<p>要移动窗口到另一个工作区，只需按下 <code>$mod + Shift + num</code>，<code>num</code> 是目标工作区的编号（这就像切换工作区的时候）。与切换工作区类似，如果目标工作区不存在，则会被创建。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="调整大小"><a class="header" href="#调整大小">调整大小</a></h1>
<p>改变容器大小最简单的方法是使用鼠标：抓住边框，移动鼠标调整到想要的大小。</p>
<p>还可以使用 <a href="https://zjuyk.site/i3wm-userguide-zh/%E9%85%8D%E7%BD%AEi3/%E7%BB%91%E5%AE%9A%E6%A8%A1%E5%BC%8F.html">绑定模式</a> ，定义一个通过键盘调整大小的模式。要查看绑定模式的使用示例，请浏览 i3 提供的 <a href="https://github.com/i3/i3/blob/next/etc/config.keycodes">默认配置</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="原地重启-i3"><a class="header" href="#原地重启-i3">原地重启 i3</a></h1>
<p>要原地重新启动 i3（从而在出现错误时进入干净状态，或者要升级到 i3 的较新版本时），可以使用 <code>$mod + Shift + r</code> 按键。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="退出-i3"><a class="header" href="#退出-i3">退出 i3</a></h1>
<p>要在不杀死 X 服务器的情况下干净利落地退出 i3，可以使用 <code>$mod + Shift + e</code> 按键。默认情况下，如果真要退出，会弹出对话框要求确认。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="浮动模式"><a class="header" href="#浮动模式">浮动模式</a></h1>
<p>浮动模式对立于平铺模式。窗口的位置和大小不由 i3 自动管理，而交由你手动管理。 使用这个模式与平铺模式的范例有所矛盾，但对于一些极端的情况会特别有用，比如“另存为”对话框，或者工具栏窗口（GIMP 或类似的软件有）。这些窗口通常会设置适当的提示并默认以浮动模式打开。</p>
<p>通过按下 <code>$mod + Shift + Space</code> 可以为窗口切换浮动模式。用鼠标拖拽窗口标题栏可以移动窗口。抓住边框并移动鼠标可以调整窗口大小。你还可以使用 <a href="https://zjuyk.site/i3wm-userguide-zh/%E9%85%8D%E7%BD%AEi3/%E6%B5%AE%E5%8A%A8%E4%BF%AE%E9%A5%B0%E9%94%AE.html">浮动修饰键</a> 进行这些操作。另一种通过鼠标调整浮动窗口大小的方式是右键点击标题栏，然后拖拽。</p>
<p>要用键盘调整浮动窗口的大小，请参阅 i3 <a href="https://github.com/i3/i3/blob/next/etc/config.keycodes">默认配置</a> 提供的调整大小绑定模式。</p>
<p>浮动窗口始终位于平铺窗口的顶部。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="树"><a class="header" href="#树">树</a></h1>
<p>i3 通过树来存储所有关于 X11 输出、工作区和窗口布局的信息。
树的根节点是 X11 根窗口，接下来是 X11 的输出，
然后是区域和内容的容器、工作区，最后到窗口本身。
在之前版本的 i3 中，我们使用过链表等结构存储输出和工作区，
针对每个工作区有单独的表。
这种方法现在被证明是复杂、难于使用、理解和实现的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="由容器构成的树"><a class="header" href="#由容器构成的树">由容器构成的树</a></h1>
<p>构成树的积木被称为容器（<code>Containers</code>）。
容器可以容纳窗口
（这里指 X11 的窗口，你可以看见并且使用的窗口，比如浏览器）。
容器也可以容纳一个或多个容器。
我们以一个简单的工作区为例：
i3 启动在一个单显示器，单工作区的环境中。
你打开了两个终端窗口，你会看到：</p>
<p><img src="%E6%A0%91/./tree-shot4.png" alt="一个标准的工作区内有两个终端" /></p>
<p>他们构成的树像这样：</p>
<p><img src="%E6%A0%91/./img/simple-tree.svg" alt="树的示意图" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="方向与切分容器"><a class="header" href="#方向与切分容器">方向与切分容器</a></h1>
<p>只有在使用树状的数据结构来维护布局时，
我们才能很自然地理解切分容器（Split Containers）。</p>
<p>在 i3 中，每个容器都有方向
（水平（horizontal），垂直（vertical）或者未指定（unspecified）），
方向与容器中的布局有关
（当使用垂直切分（splitv）或堆叠（stacking）时是垂直方向，
使用水平切分（splith）或标签式（tabbed）是水平方向）。</p>
<p>所以，在上一个例子中，默认的工作区布局是垂直切分
（因为现在大多数屏幕都是横向的），如果我们把它改成垂直切分
（在默认配置文件中是 <code>$mod+v</code>），并且打开两个终端，
i3 会这样处理你的两个窗口：</p>
<p><img src="%E6%A0%91/./tree-shot2.png" alt="" /></p>
<p>一个关于 i3 自 4 版本以来的有趣的特性是你可以分割几乎所有东西。
假设你现在有两个终端水平切分（也就是水平方向）在一个工作区内，
移动焦点到右边的终端。
现在你想在现在终端的下面打开一个新的终端。
但是如果你现在直接打开终端，它会创建在现在水平切分的右边。
你需要按下 <code>$mod+v</code>，来使用垂直切分处理右边的容器
（如果需要水平切分，则使用 <code>$mod+h</code>）。
现在你可以打开一个新的终端，它会在刚刚焦点所在的终端的下方：</p>
<p><img src="%E6%A0%91/./tree-shot1.png" alt="" /></p>
<p>此时的树形示意图如下（其中的红色表示你目前的焦点）：</p>
<p><img src="%E6%A0%91/./img/splitv-tree.svg" alt="" /></p>
<p>你可能已经猜到了，你的切分容器的深度没有限制。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="聚焦父容器"><a class="header" href="#聚焦父容器">聚焦父容器</a></h1>
<p>让我们继续上面的例子。我们有一个左侧的终端和两个在右侧垂直分割的终端。
现在的焦点在右下的终端上，当我们打开一个新的终端，它会出现在现在这个终端的下方。</p>
<p>所以，我们该如何在现有终端的右边打开一个新的终端呢？
答案是通过 <code>focus parent</code> 切换焦点到目前焦点的父容器。
在默认的设置中，我们使用 <code>$mod+a</code> 聚焦到容器树中的父节点上
（你可以重复多次这个操作直到回到工作区容器）。
这个例子中，你将会聚焦在垂直分割容器上，
它是水平分割的工作区的子容器。
现在，新创建的终端将会出现在垂直分割容器的右边。</p>
<p><img src="%E6%A0%91/./tree-shot3.png" alt="" />
图四：聚焦父容器，然后打开新终端</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="隐式容器"><a class="header" href="#隐式容器">隐式容器</a></h1>
<p>在一些情况下，i3 需要隐式地创建一个容器来完成你的命令。</p>
<p>考虑这样的情况：你在一个单屏幕单工作区的环境中打开 i3，
然后打开了三个终端，按照默认的设置，
现在这些终端会在工作区容器中水平分割。</p>
<p>现在你要移动其中一个终端到下方（默认设置中是 <code>$mod+Shift+j</code>）。
工作区的方向将被调整为垂直方向。
现在工作区容器中包括了被移动的终端窗口（在下方）和一个新的水平分割容器。
新的水平分割容器被用来容纳另外两个终端窗口。
如果你现在把工作区容器改为标签式堆叠，
你会看到标题栏上出现了对分割容器的描述（比如 <code>H[urxvt firefox]</code>），
另一个窗口则是你刚刚移动到下方的终端窗口。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="配置-i3"><a class="header" href="#配置-i3">配置 i3</a></h1>
<p>这是真正的乐趣开始的地方。<code>;-)</code></p>
<p>大多数的配置依赖于你的理想的工作环境，
我们并不能作出一个对所有人都合理的默认设置。</p>
<p>我们并没有使用某一种编程语言作为配置文件，
但我们还是在你对于一个窗口管理器的需求范围内，
提供了相当的灵活性。</p>
<p>比如，你可以通过配置绑定跳转到某个特定的窗口，
你可以让特定的应用程序被打开在特定的工作区内，
你可以自动打开一些应用程序，
你可以改变 i3 的颜色，
你可以按照你的需求绑定按键来做你想做的事情。</p>
<p>想要改变 i3 的配置，你可以从 <code>/etc/i3/config</code> 拷贝一份默认的配置文件到
<code>~/.i3/config</code> （或者符合 XDG 目录结构的 <code>~/.config/i3/config</code>），
然后用你喜欢的文本编辑器编辑它。</p>
<p>当你首次打开 i3 （或者没有配置文件的每次）时，
i3 会建议你建立一个新的配置文件。
你可以选择 Alt(Mod1) 或 Windows(Mod4) 作为默认的修饰键。
同时，新创建的配置文件会使用你当前的键盘布局。
如果你需要手动打开配置文件创建向导，
可以使用命令 <code>i3-config-wizard</code>。
注意，仅当你没有 <code>~/.i3/config</code> 时，
配置文件向导才会运行，否则它会退出。</p>
<p>自 i3 4.0，我们使用了一种新的配置文件。
i3 会通过一些关键词自动检测配置文件版本，
如果你希望你的配置文件被当作这种新格式，
你的配置文件中需要包含这一行：</p>
<pre><code># i3 config file (v4)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="注释"><a class="header" href="#注释">注释</a></h1>
<p>你可以在配置文件中使用注释来解释你的配置文件。
注释以 <code>#</code> 开头，并且只能被用在行首。</p>
<p>举例：</p>
<pre><code># This is a comment
# 这是一句注释
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字体"><a class="header" href="#字体">字体</a></h1>
<p>i3 可以用 X 核心字体和 FreeType 字体（通过 Pango 实现）渲染窗口标题。</p>
<p>对于 X 核心字体，你可以使用 <code>xfontsel(1)</code> 生成 X 核心字体描述，如果要渲染特殊字符（Unicode 字符），你需要一个支持 ISO-10646 编码的字体。</p>
<p>对于 FreeType 字体，你可能需要指定字体系列（Family）、风格（Style）、粗细（Weight）、变种（Variant），拉伸（Stretch）和大小（Size）。FreeType 字体支持从右到左的渲染，并且通常比 X 核心字体包括更多的 Unicode 符号。</p>
<p>i3 如果没能成功设置字体，会在日志文件中输出错误并且回退到一个可用的字体。</p>
<p>格式：</p>
<pre><code>font &lt;X 核心字体描述&gt;
font pango:&lt;字体系列&gt; [&lt;其他选项&gt;] &lt;大小&gt;
</code></pre>
<p>示例：</p>
<pre><code>font -misc-fixed-medium-r-normal--13-120-75-75-C-70-iso10646-1
font pango:DejaVu Sans Mono 10
font pango:DejaVu Sans Mono, Terminus Bold Semi-Condensed 11
font pango:Terminus 11px
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="键盘绑定"><a class="header" href="#键盘绑定">键盘绑定</a></h1>
<p>键盘绑定让 i3 可以在你按下某个特定的键时执行某个命令。
你可以绑定数字码（keycodes）或符号码（keysyms）
（可以混用这两者，但是 i3 将不能确保这些绑定不会重复）。</p>
<ul>
<li>
<p>符号码（keysym）可以描述一个特定的符号，比如 <code>a</code> 或者 <code>b</code>，但是我们用 <code>underscore</code> 表示 <code>_</code> 而不是它本身。
你可以用 <code>xmodmap(1)</code> 来重新映射这些键。
要获得当前的符号码设置，你可以使用 <code>xmodmap -pke</code>。
如果交互式地要看到某个键对应着什么符号码，你可以使用 <code>xev</code>。</p>
</li>
<li>
<p>数字码（keycodes）不需要分配一个符号（对于某些笔记本或者其他设备的快捷键很有用），即使你（用 xmodmap）换用其他的键盘布局，这些绑定也不会发生变化。</p>
</li>
</ul>
<p>我们的建议是：
如果你经常切换键盘布局，但想要键盘绑定在物理键盘上的位置不发生变化，可以用数字码。如果你并不需要切换键盘布局，并且希望有一个整洁且简单的配置文件，应当使用符号码。</p>
<p>一些工具（比如 <code>import</code> 或者 <code>xdotool</code>）可能不应当在一个键被按下（KeyPress）时被触发。
对于这种情况，你可以用 <code>--release</code> 选项来配置这个绑定。
这会让指令在这个键被松开（KeyRelease）的时候被执行。</p>
<p>格式：</p>
<pre><code>bindsym [--release] [&lt;组&gt;+][&lt;修饰键&gt;+]&lt;符号码&gt; 指令
bindcode [--release] [&lt;组&gt;+][&lt;修饰键&gt;+]&lt;数字码&gt; 指令
</code></pre>
<p>举例：</p>
<pre><code># 全屏
bindsym $mod+f fullscreen toggle

# 重启 i3wm
bindsym $mod+Shift+r restart

# 笔记本特定的键
bindcode 214 exec --no-startup-id /home/michael/toggle_beamer.sh

# 在按（松开） $mod+x 的时候模拟输入 ctrl+v
bindsym --release $mod+x exec --no-startup-id xdotool key --clearmodifiers ctrl+v

# 在按（松开） $mod+x 的时候截图
bindsym --release $mod+x exec --no-startup-id import /tmp/latest-screenshot.png
</code></pre>
<p>可用的修饰键（Modifier）有：
<code>Mod1-Mod5</code>, <code>Shift</code>, <code>Control</code>。
这些是标准的修饰键，你可以参考 <code>xmodmap(1)</code></p>
<p>对于 <code>Group1, Group2, Group3, Group4</code>:
当你使用多种键盘布局时（比如使用了 <code>setxkbmap -layout us,ru</code>），你可以指定在哪一个 XKB 组中这个绑定应该被激活。
默认情况下键盘绑定会被转换到 Group1 中，并且在所有组中都被激活。
如果你需要在某个键盘布局中覆盖绑定，可以指定相应的组。
出于向后兼容性考虑，<code>Mode_switch</code> 是 <code>Group2</code> 的别名。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="鼠标绑定"><a class="header" href="#鼠标绑定">鼠标绑定</a></h1>
<p>当你在某个特定的区域按下某个鼠标按键时，i3 可以执行一个指令。
（详见 <a href="%E9%85%8D%E7%BD%AEi3/../%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8/%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8.html#%E5%91%BD%E4%BB%A4%E6%9D%A1%E4%BB%B6">命令列表#命令条件</a>）
你可以用类似按键绑定的方式配置鼠标绑定。</p>
<p>格式：</p>
<pre><code>bindsym [--release] [--border] [--whole-window] [--exclude-titlebar] [&lt;修饰键&gt;+]按键&lt;n&gt; 命令
</code></pre>
<p>默认情况下，这些绑定仅在你点击一个窗口的标题栏时生效。</p>
<p>如果你指定了 <code>--release</code> 选项，i3wm 会在你松开鼠标按键时触发这个指令。</p>
<p>如果你指定了 <code>--whole-window</code> 选项，这个绑定在你点击窗口的其他部分是也会生效，但不包括窗口的边框。
如果需要在点击窗口边框时触发指令，你可以指定 <code>--border</code> 选项。</p>
<p>如果你指定了 <code>--exclude-titlebar</code> 选项，点击标题栏将不会触发指令。</p>
<p>举例：</p>
<pre><code># 通过在标题栏中键杀死一个窗口
bindsym --release button2 kill

# 通过在按下 $mod 时在窗口的任意位置中键来杀死一个窗口
bindsym --whole-window $mod+button2 kill

# 通过右键设置漂浮的窗口
bindsym button3 floating toggle
bindsym $mod+button3 floating toggle

# 用鼠标侧面的按键来移动窗口
bindsym button9 move left
bindsym button8 move right
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="绑定模式"><a class="header" href="#绑定模式">绑定模式</a></h1>
<p>你可以通过绑定模式配置多套绑定。
当你切换到另一个绑定模式时，当前模式的所有绑定将不再有效，
只有在新的模式中定义的绑定是有效的，直到你退出这个模式。
默认情况下 i3wm 处于 <code>default</code> 模式，没有定义模式的绑定会处于这一模式中。</p>
<p>要使用绑定模式，你需要定义一个绑定模式，然后切换到它。
在配置文件中，定义一个模式和切换到一个模式都使用 <code>mode</code>。
如果把 <code>mode</code> 作为配置项使用，你可以定义在这个模式中生效的绑定。
如果把 <code>mode</code> 作为指令使用，触发它将会使 i3wm 切换到这个模式。</p>
<p>我们建议你使用 <a href="%E9%85%8D%E7%BD%AEi3/./%E5%8F%98%E9%87%8F.html">变量</a> 简化配置，使配置易于维护。</p>
<p>我们建议你定义一个绑定来切换回默认的绑定模式。
你可以对绑定模式使用 <a href="%E9%85%8D%E7%BD%AEi3/../%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8/%E7%AA%97%E5%8F%A3%E6%A0%87%E9%A2%98%E6%A0%BC%E5%BC%8F.html#pango_markup">pango_markup</a>，
但你需要在定义绑定模式时显式地指定 <code>--pango-markup</code> 选项。</p>
<p>格式：</p>
<pre><code># 作为配置项
mode [--pango_markup] &lt;name&gt;

# 作为指令
mode &lt;name&gt;
</code></pre>
<p>举例：</p>
<pre><code># 按下 $mod+o 之后
# 用 f 打开 firefox，用 t 打开 thunderbird
# 用回车或 Esc 键返回默认模式
set $mode_launcher Launch: [f]irefox [t]hunderbird
bindsym $mod+o mode &quot;$mode_launcher&quot;

mode &quot;$mode_launcher&quot; {
    bindsym f exec firefox
    bindsym t exec thunderbird

    bindsym Escape mode &quot;default&quot;
    bindsym Return mode &quot;default&quot;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="浮动修饰键"><a class="header" href="#浮动修饰键">浮动修饰键</a></h1>
<p>你有两种方法来使用鼠标移动浮动的窗口，
一种方法是拖拽标题栏，另一种方法被称为浮动修饰键。
当你按下浮动修饰键时，你可以拖拽窗口的任意部分来移动它。
通常我们会用你管理窗口的键作为浮动修饰键（比如 Mod1）。
你可以按下 Mod1，左键点击并拖拽一个窗口到你想要的位置。</p>
<p>当你按住浮动修饰键时，你还可以用右键拖拽改变窗口的大小。
如果你同时还按住了 Shift 键，窗口的宽和高会成比例地改变，
换句话说，窗口的宽高比会被保留。</p>
<p>格式：</p>
<pre><code>floating_modifier &lt;修饰键&gt;
</code></pre>
<p>例子：</p>
<pre><code>floating_modifier Mod1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="限制浮动窗口大小"><a class="header" href="#限制浮动窗口大小">限制浮动窗口大小</a></h1>
<p>浮动窗口的宽和高可以有最大值或者最小值。
在 <code>floating_maximum_size</code> 中使用 -1 表示这个方向上的长度不会被限制。
如果没有定义 <code>floating_maximum_size</code>，或者输入了 0，i3 会使用默认的设置限制窗口大小。
<code>floating_minimum_size</code> 与 <code>floating_maximum_size</code> 是类似的，它限制浮动窗口的最小大小。</p>
<p>格式：</p>
<pre><code>floating_minimum_size &lt;宽&gt; x &lt;高&gt;
floating_maximum_size &lt;宽&gt; x &lt;高&gt;
</code></pre>
<p>例子：</p>
<pre><code>floating_minimum_size 75 x 50
floating_maximum_size -1 x -1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="新工作区方向"><a class="header" href="#新工作区方向">新工作区方向</a></h1>
<p>新的工作区会有默认的布局方向，
如果屏幕是横向的（宽大于高），默认会进行水平布局，
如果屏幕是竖向的（高大于宽），默认会进行垂直布局。</p>
<p>你可以使用 <code>default_orientation</code> 来改变这种行为。</p>
<p>格式：</p>
<pre><code>default_orientation horizontal|vertical|auto
</code></pre>
<p>例子：</p>
<pre><code>default_orientation vertical
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="新工作区容器布局模式"><a class="header" href="#新工作区容器布局模式">新工作区容器布局模式</a></h1>
<p>当你创建新工作区时，这个选项可以定义默认的容器布局模式。</p>
<p>格式：</p>
<pre><code>workspace_layout default|stacking|tabbed
</code></pre>
<p>举例：</p>
<pre><code>workspace_layout tabbed
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="窗口标题对齐"><a class="header" href="#窗口标题对齐">窗口标题对齐</a></h1>
<p>这个选项可以指定窗口标题对齐的方向，默认为 <code>left</code>（左对齐）。</p>
<p>格式：</p>
<pre><code>title_align left|center|right
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="新窗口默认边框样式"><a class="header" href="#新窗口默认边框样式">新窗口默认边框样式</a></h1>
<p>这个选项决定了新窗口的边框样式。
默认值是 <code>normal</code>。
<code>default_floating_border</code> 仅对于新创建的浮动窗口有效（例如某些对话框），
而不对那些创建时不是浮动窗口，而在之后才被调整为浮动的窗口有效。</p>
<p>如果被设置为 <code>pixel</code>，新窗口将会保留边框，而不显示标题栏。
如果被设置为 <code>normal</code>，新窗口将同时具有边框和标题栏。
同时，你还可以指定边框的宽度。</p>
<p>格式：</p>
<pre><code>default_border normal|none|pixel
default_border normal|pixel &lt;边框宽度&gt;
default_floating_border normal|none|pixel
default_floating_border normal|pixel &lt;边框宽度&gt;
</code></pre>
<p>请注意，<code>new_window</code> 和 <code>new_float</code> 已经被弃用，他们将在未来的更新中被移除。
我们强烈建议你使用新的选项。</p>
<p>举例：</p>
<pre><code>default_border pixel
</code></pre>
<p>指定 <code>normal</code> 和 <code>pixel</code> 时，可以同时指定宽度：</p>
<p>举例：</p>
<pre><code># 和 none 效果一致
default_border pixel 0

# 3 px 宽的无标题栏边框
default_border pixel 3
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="靠近屏幕边缘隐藏边框"><a class="header" href="#靠近屏幕边缘隐藏边框">靠近屏幕边缘隐藏边框</a></h1>
<p>你可以使用 <code>hide_edge_borders</code> 隐藏连接在屏幕边缘上的窗口边框。
如果你使用滚动条，或者你只是不想浪费屏幕边框上的两列像素，这个选项会非常有用。
如果设置为 <code>smart</code>，当工作区内只有一个窗口可见时，边框会被隐藏；
但当工作区内有多个可见的窗口，边框会被保留。
默认设置是 <code>none</code>。</p>
<p>格式：</p>
<pre><code>hide_edge_borders none|vertical|horizontal|both|smart
</code></pre>
<p>举例：</p>
<pre><code># 隐藏垂直方向的，屏幕边缘上的边框
hide_edge_borders vertical
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="针对窗口专用命令for_window"><a class="header" href="#针对窗口专用命令for_window">针对窗口专用命令（for_window）</a></h1>
<p>使用 <code>for_window</code> 指令，你可以让 i3 在遇到特定窗口时执行任何命令。例如，将窗口设置为浮动或更改其边框样式。</p>
<p><strong>语法</strong>：</p>
<pre><code>for_window &lt;criteria&gt; &lt;command&gt;
</code></pre>
<p><strong>例子</strong>：</p>
<pre><code># 对所有的 XTerm 窗口开启浮动模式
for_window [class=&quot;XTerm&quot;] floating enable

# 使所有的 urxvt 窗口的边框为 1 像素：
for_window [class=&quot;urxvt&quot;] border pixel 1

# 一个很少用到但是很有趣的例子：
# 当我切换到 `~/work` 目录时使所有的窗口浮动
for_window [title=&quot;x200: ~/work&quot;] floating enable
</code></pre>
<p>有效标准与命令的标准相同，请参阅 <a href="https://zjuyk.site/i3wm-userguide-zh/%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8/%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8.html#%E5%91%BD%E4%BB%A4%E6%9D%A1%E4%BB%B6">命令列表#命令条件</a>。在运行时只能执行命令，不能执行配置指令，请参阅 <a href="%E9%85%8D%E7%BD%AEi3/../%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8/%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8.html">命令列表</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="打开窗口不聚焦"><a class="header" href="#打开窗口不聚焦">打开窗口不聚焦</a></h1>
<p>当一个新窗口出现时，它将被聚焦。<code>no_focus</code> 指令可以防止这种情况发生，并且必须与 <a href="https://zjuyk.site/i3wm-userguide-zh/%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8/%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8.html#%E5%91%BD%E4%BB%A4%E6%9D%A1%E4%BB%B6">命令列表#命令条件</a> 结合使用。</p>
<p>请注意，这并不适用于所有情况，例如，当将数据提供给正在运行的应用程序导致它请求被聚焦时。
要配置这种情况下的行为，请参阅 <a href="%E9%85%8D%E7%BD%AEi3/../%E9%85%8D%E7%BD%AEi3/%E8%81%9A%E7%84%A6%E7%AA%97%E5%8F%A3%E6%B4%BB%E5%8A%A8.html">聚焦窗口活动</a>。</p>
<p><code>no_focus</code> 对于工作区上的第一个窗口也将被忽略，因为在这种情况下不应该有理由不聚焦窗口。
这可以跟 <code>workspace_layout</code> 结合使用以获得更好的可用性。</p>
<p><strong>语法：</strong></p>
<pre><code>no_focus &lt;criteria&gt;
</code></pre>
<p><strong>例子：</strong></p>
<pre><code>no_focus [window_role=&quot;pop-up&quot;]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="变量"><a class="header" href="#变量">变量</a></h1>
<p>正如你在关于键盘绑定的部分中学到的那样，你将必须配置大量包含修饰键的绑定。
如果你想节省一些输入时间并能够更改你以后使用的修饰符，变量会很方便。</p>
<p>语法：</p>
<pre><code>set $&lt;name&gt; &lt;value&gt;
</code></pre>
<p>例子：</p>
<pre><code>set $m Mod1
bindsym $m+Shift+r restart
</code></pre>
<p>解析时直接替换文件中的变量。变量扩展不是递归的，因此不可能使用包含另一个变量的值来定义变量。
没有花哨的处理，也绝对没有改变这一点的计划。
如果你需要更动态的配置，你应该创建一个小脚本来生成配置文件并在启动 i3 之前运行它（例如在你的 <code>~/.xsession</code> 文件中）。</p>
<p>另请参阅 <a href="%E9%85%8D%E7%BD%AEi3/./X%E8%B5%84%E6%BA%90.html">xresources</a> 以了解如何根据从 X 资源数据库加载的资源创建变量。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="x-资源"><a class="header" href="#x-资源">X 资源</a></h1>
<p><a href="%E9%85%8D%E7%BD%AEi3/./%E5%8F%98%E9%87%8F.html">变量</a> 也可以使用在 X 资源数据库中配置的值来创建。
例如，这有助于避免在 i3 配置中配置颜色值。
相反，这些值可以在 X 资源数据库中配置一次，以在许多 X 应用程序中实现易于维护、一致的颜色主题。</p>
<p>定义一个资源将从资源数据库中加载该资源并将其值赋给指定的变量。
这是逐字完成的，因此值必须采用 i3 使用的格式。
如果无法从数据库加载资源，则必须指定回退。</p>
<p>语法：</p>
<pre><code>set_from_resource $&lt;name&gt; &lt;resource_name&gt; &lt;fallback&gt;
</code></pre>
<p>例子：</p>
<pre><code># `~/.Xresources` 应该包含类似下行
#     *color0: #121212
# 同时正确加载，例如，通过
#     xrdb ~/.Xresources
# 该值被其他应用程序获取（例如 URxvt）和在 i3 配置文件中这样使用:
set_from_resource $black i3wm.color0 #000000
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="自动将客户端放到指定工作区"><a class="header" href="#自动将客户端放到指定工作区">自动将客户端放到指定工作区</a></h1>
<p>要自动在特定工作区上显示特定窗口，你可以直接分配。
你可以使用任何标准来匹配窗口，请参阅 <a href="https://zjuyk.site/i3wm-userguide-zh/%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8/%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8.html#%E5%91%BD%E4%BB%A4%E6%9D%A1%E4%BB%B6">命令列表#命令条件</a>。
<code>assign</code> 和 <code>for_window &lt;criteria&gt; move to workspace</code> 的区别在于
前者只会在应用程序映射窗口时执行（映射意味着实际将其显示在屏幕上）而后者将在符合指定条件的窗口将其属性更改为某些内容时执行。</p>
<p>因此，建议你尽可能匹配窗口类（和实例，如果合适）而不是窗口标题，因为某些应用程序首先创建它们的窗口，然后担心设置正确的标题。
例如 Vimperator 的 Firefox，
窗口启动时被命名为 Firefox，只有当 Vimperator 被加载时，标题才会改变。
由于 i3 会在应用程序映射窗口后立即获取标题，因此在这种情况下，你必须在 <code>Firefox</code> 上进行匹配。
另一个已知问题是 Spotify，它在映射窗口时不会设置类提示，这意味着你必须使用 <code>for_window</code> 规则将 Spotify 分配给特定的工作区。
最后，不支持使用 <code>assign [tiling]</code> 和 <code>assign [floating]</code>。</p>
<p>你还可以指定一个窗口以显示在特定输出上。
你可以使用 RandR 名称（例如 <code>VGA1</code>）或与当前聚焦的工作区（例如 <code>left</code> 和 <code>down</code>）的输出相关的名称。</p>
<p>分配由 i3 按照它们在配置文件中出现的顺序进行处理。
第一次匹配窗口的分配规则直接生效，不考虑后面的分配。</p>
<p><strong>语法：</strong></p>
<pre><code>assign &lt;criteria&gt; [→] [workspace] [number] &lt;workspace&gt;
assign &lt;criteria&gt; [→] output left|right|up|down|primary|&lt;output&gt;
</code></pre>
<p><strong>例子：</strong></p>
<pre><code># 将 URxvt 终端分配到第二个工作空间
assign [class=&quot;URxvt&quot;] 2

# 相同但更精确（精确匹配而不是子字符串）
assign [class=&quot;^URxvt$&quot;] 2

# 相同但有个漂亮的箭头 :)
assign [class=&quot;^URxvt$&quot;] → 2

# 分配到已命名的工作空间
assign [class=&quot;^URxvt$&quot;] → work

# 分配到第二个工作空间，不考虑名字
assign [class=&quot;^URxvt$&quot;] → number 2

# 你也可以指定数字+名字。如果第二个工作空间存在的话
# assign will skip the text part.
assign [class=&quot;^URxvt$&quot;] → number &quot;2: work&quot;

# 启动 urxvt -name irssi
assign [class=&quot;^URxvt$&quot; instance=&quot;^irssi$&quot;] → 3

# 将 URxvt 分配给当前的输出屏幕右侧
assign [class=&quot;^URxvt$&quot;] → output right

# 将 URxvt 分配到主输出屏幕
assign [class=&quot;^URxvt$&quot;] → output primary
</code></pre>
<p>请注意，你可能尚未配置主输出。为此，请运行：</p>
<pre><code>xrandr --output &lt;output&gt; --primary
</code></pre>
<p>此外，箭头不是必需的，它看起来不错:-)。如果你决定使用它，它必须是一个 UTF-8 编码的箭头，而不是 -&gt; 或类似的东西。</p>
<p>要获取类和实例，你可以使用 <code>xprop</code>。单击窗口后，你将看到以下输出：</p>
<p><strong>xprop:</strong></p>
<pre><code>WM_CLASS(STRING) = &quot;irssi&quot;, &quot;URxvt&quot;
</code></pre>
<p>WM_CLASS 的第一部分是实例（本例中为“irssi”），第二部分是类（本例中为“URxvt”）。</p>
<p>如果你在分配时遇到任何问题，请务必先检查 i3 日志文件（请参阅 https://i3wm.org/docs/debugging.html）。它包括有关匹配过程的更多详细信息以及启动时窗口的实际类、实例和标题。</p>
<p>请注意，如果你只想在特定工作区上启动应用程序一次，但不想永久分配它的所有实例，
则可以在配置文件中使用 i3 的启动通知支持（请参阅 <a href="https://zjuyk.site/i3wm-userguide-zh/%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8/%E8%BF%90%E8%A1%8C%E5%BA%94%E7%94%A8%EF%BC%88exec%EF%BC%89.html">exec</a>）通过以下方式：</p>
<p><strong>在工作区 3 上启动 iceweasel（一次）：</strong></p>
<pre><code># 在工作区 3 上启动 iceweasel，然后切换回工作区 1
# (作为命令行工具，i3-msg 不支持启动通知，因此请使用 exec --no-startup-id。)
# (使用 i3 的 exec 命令启动 iceweasel 使 i3 创建一个启动通知上下文，如果没有它，iceweasel 窗口
# 不能匹配到启动命令的工作区。）
exec --no-startup-id i3-msg 'workspace 3; exec iceweasel; workspace 1'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="在-i3-启动时自动运行应用"><a class="header" href="#在-i3-启动时自动运行应用">在 i3 启动时自动运行应用</a></h1>
<p>通过在按键绑定时使用 <code>exec</code> 关键字，你可以配置 i3 在初始启动时将执行哪些命令。
<code>exec</code> 命令不会在重新启动 i3 时运行，如果你需要在重新启动 i3 时也运行命令，则应使用 <code>exec_always</code> 关键字。这些命令将按顺序运行。</p>
<p>有关 ; （分号）和 ,（逗号）的特殊含义的详细信息，请参见 <a href="https://zjuyk.site/i3wm-userguide-zh/%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8/%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8.html#%E5%91%BD%E4%BB%A4%E9%93%BE%E6%8E%A5">命令列表#命令链接</a>：它们在 i3 中将命令链接在一起，因此如果它们出现在你的命令中，你需要使用带引号的字符串（如 <a href="https://zjuyk.site/i3wm-userguide-zh/%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8/%E8%BF%90%E8%A1%8C%E5%BA%94%E7%94%A8%EF%BC%88exec%EF%BC%89.html">exec_quoting</a> 中所示）。</p>
<p><strong>语法：</strong></p>
<pre><code>exec [--no-startup-id] &lt;command&gt;
exec_always [--no-startup-id] &lt;command&gt;
</code></pre>
<p><strong>示例：</strong></p>
<pre><code>exec chromium
exec_always ~/my_script.sh

# 执行终端仿真器 urxvt，忽略启动通知
exec --no-startup-id urxvt
</code></pre>
<p>参数 --no-startup-id 在 <a href="https://zjuyk.site/i3wm-userguide-zh/%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8/%E8%BF%90%E8%A1%8C%E5%BA%94%E7%94%A8%EF%BC%88exec%EF%BC%89.html">exec</a> 有详细介绍。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="自动将工作区放到指定显示屏"><a class="header" href="#自动将工作区放到指定显示屏">自动将工作区放到指定显示屏</a></h1>
<p>如果你习惯于将客户端分配到工作区，其实将工作区放在特定屏幕上可能会更方便。
此外，将工作区分配给屏幕将决定 i3 在添加屏幕或启动时将哪个工作区用于新屏幕（例如，默认情况下，它将为第一个屏幕使用 1，为第二个屏幕使用 2，依此类推）。</p>
<p><strong>语法：</strong></p>
<pre><code>workspace &lt;workspace&gt; output &lt;output1&gt; [output2]…
</code></pre>
<p>输出是你将屏幕附加到的 RandR 输出的名称。
在笔记本电脑上，你可能将 VGA1 和 LVDS1 作为输出名称。
你可以通过运行 <code>xrandr --current</code> 来查看现在的输出屏幕。</p>
<p>如果你的 X 服务器支持 RandR 1.5 或更新版本，i3 将使用 RandR 监视器对象而不是输出对象。
运行 <code>xrandr --listmonitors</code> 以查看列表。
通常，一个监视器对象只包含一个输出，并且与输出具有相同的名称；
但如果不是这种情况，你可以在 i3 的配置中指定监视器或输出的名称。
例如，Dell UP2414Q 内部使用两个定标器，因此其输出名称可能是“DP1”和“DP2”，但显示器名称是“Dell UP2414Q”。</p>
<p>（请注意，即使你指定了不跨越整个监视器的输出名称，i3 仍将使用包含监视器的整个区域，而不仅仅是输出的区域。）</p>
<p>你可以指定多个输出。i3 将使用第一个可用的输出屏幕。</p>
<p>如果你使用命名工作区，则必须引用它们：</p>
<p><strong>例子：</strong></p>
<pre><code>workspace 1 output LVDS1
workspace 2 output primary
workspace 5 output VGA1 LVDS1
workspace &quot;2: vim&quot; output VGA1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="改变颜色"><a class="header" href="#改变颜色">改变颜色</a></h1>
<p>你可以更改 i3 用于绘制窗口装饰的所有颜色。</p>
<p><strong>语法：</strong></p>
<pre><code>&lt;colorclass&gt; &lt;border&gt; &lt;background&gt; &lt;text&gt; &lt;indicator&gt; &lt;child_border&gt;
</code></pre>
<p>colorclass 可以是以下之一：</p>
<p><code>client.focused</code></p>
<p>当前具有焦点的客户端。</p>
<p><code>client.focused_inactive</code></p>
<p>客户端是其容器的焦点之一，但目前没有焦点。</p>
<p><code>client.unfocused</code></p>
<p>不是其容器的焦点之一的客户端。</p>
<p><code>client.urgent</code></p>
<p>已激活紧急提示的客户端</p>
<p><code>client.placeholder</code></p>
<p>背景和文本颜色用于绘制占位符窗口内容（恢复布局时）。边框和指示器被忽略</p>
<p><code>client.background </code></p>
<p>背景颜色将用于绘制客户端窗口的背景，客户端将在其上呈现。只有未覆盖此窗口整个区域的客户端才会显示颜色。请注意，此颜色类仅采用单一颜色。</p>
<p>颜色采用 HTML 十六进制格式 (#rrggbb)，请参见以下示例：</p>
<p><strong>例子（默认颜色）：</strong></p>
<pre><code># class                 border  backgr. text    indicator child_border
client.focused          #4c7899 #285577 #ffffff #2e9ef4   #285577
client.focused_inactive #333333 #5f676a #ffffff #484e50   #5f676a
client.unfocused        #333333 #222222 #888888 #292d2e   #222222
client.urgent           #2f343a #900000 #ffffff #900000   #900000
client.placeholder      #000000 #0c0c0c #ffffff #000000   #0c0c0c

client.background       #ffffff
</code></pre>
<p>请注意，对于窗口装饰，子窗口周围的颜色是“child_border”，而“边框”颜色只是标题栏周围的两条细线。</p>
<p>指示器颜色用于指示将在何处打开新窗口。对于水平拆分容器，右边框将绘制为指示色，对于垂直拆分容器，底部边框将绘制。这仅适用于拆分容器内的单个窗口，否则与拆分容器外的单个窗口无法区分。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="进程通信"><a class="header" href="#进程通信">进程通信</a></h1>
<p>i3 使用 Unix 套接字来提供 IPC 接口。这允许第三方程序从 i3 获取信息，例如当前工作区（以显示工作区栏），并控制 i3。</p>
<p>IPC 套接字默认启用，如果目录可用，将在 <code>$XDG_RUNTIME_DIR/i3/ipc-socket.%p</code> 中创建，如果没有则使用 <code>/tmp/i3-%u.XXXXXX/ipc-socket.%p</code>，其中 <code>%u</code> 是你的 UNIX 用户名，<code>%p</code> 是 i3 的 PID，XXXXXX 是来自可移植文件名字符集的随机字符串（请参阅 mkdtemp(3)）。</p>
<p>你可以通过环境变量 I3SOCK 或指定 ipc-socket 指令来覆盖默认路径。但是，这是不提倡，因为 i3 默认情况下会做正确的事情。
如果你决定更改它，强烈建议将其设置为你的主目录中的某个位置，以免其他用户无法创建该目录。</p>
<p><strong>例子：</strong></p>
<pre><code>ipc-socket ~/.i3/i3-ipc.sock
</code></pre>
<p>然后，你可以使用 <code>i3-msg</code> 应用程序执行 <a href="%E9%85%8D%E7%BD%AEi3/../%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8/%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8.html">命令列表</a> 中列出的任何命令。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="焦点跟随鼠标"><a class="header" href="#焦点跟随鼠标">焦点跟随鼠标</a></h1>
<p>默认情况下，当鼠标穿过窗口边界时，窗口焦点会跟随鼠标移动。
但是，如果你的设置让你的鼠标变得碍事（例如你不想完全禁用的笔记本电脑上的触摸板），你可能希望禁用鼠标跟随鼠标并仅使用键盘控制焦点。
鼠标在当前活动窗口内仍然有用（例如单击浏览器窗口中的链接）。</p>
<p><strong>语法：</strong></p>
<pre><code>focus_follows_mouse yes|no
</code></pre>
<p><strong>例子：</strong></p>
<pre><code>focus_follows_mouse no
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="鼠标活动"><a class="header" href="#鼠标活动">鼠标活动</a></h1>
<p>默认情况下，当将焦点切换到不同输出上的窗口时（例如，将工作区 3 上的窗口聚焦到输出 VGA-1 上，来自 LVDS-1 上的工作区 2），鼠标光标会聚焦到该窗口的中心。</p>
<p>使用 <code>mouse_warping</code> 选项，你可以控制鼠标光标何时应该变形。<code>none</code> 完全禁用变形，而输出是上述默认行为。</p>
<p><strong>语法：</strong></p>
<pre><code>mouse_warping output|none
</code></pre>
<p><strong>例子：</strong></p>
<pre><code>mouse_warping none
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="全屏模式下的弹出窗口"><a class="header" href="#全屏模式下的弹出窗口">全屏模式下的弹出窗口</a></h1>
<p>当处于全屏模式时，某些应用程序仍会打开弹出窗口（以 Xpdf 为例）。这是因为这些应用程序可能不知道它们处于全屏模式（它们不检查相应的提示）。在这种情况下，可以做三件事：</p>
<ol>
<li>
<p>如果仅属于全屏应用程序，则显示弹出窗口。这是默认设置，对于大多数用户来说应该是合理的行为。</p>
</li>
<li>
<p>只需忽略弹出窗口（不要映射它）。当你处于全屏模式时，这不会打扰你。但是，某些应用程序可能对此反应不佳（死锁，直到你退出全屏）。</p>
</li>
<li>
<p>离开全屏模式。</p>
</li>
</ol>
<p><strong>语法：</strong></p>
<pre><code>popup_during_fullscreen smart|ignore|leave_fullscreen
</code></pre>
<p><strong>例子：</strong></p>
<pre><code>popup_during_fullscreen smart
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="焦点环绕"><a class="header" href="#焦点环绕">焦点环绕</a></h1>
<p>默认情况下，当在具有多个窗口或子容器的容器中时，当尝试将焦点移动到容器边缘上时（并且该方向没有其他容器）—— 焦点环绕，相反的窗口将被聚焦。</p>
<p>如果需要，你可以通过将 <code>focus_wrapping</code> 配置指令设置为值 <code>no</code> 来禁用此行为。</p>
<p>启用后，如果指定方向上有另一个窗口或容器，则默认情况下不会发生焦点环绕，而是将焦点设置在该窗口或容器上。这是默认行为，因此你可以导航到所有窗口而无需使用 <code>focus parent</code>。</p>
<p>如果你希望焦点始终环绕并且你知道使用 <code>focus parent</code> 切换到不同的容器，则可以将 <code>focus_wrapping</code> 设置为值 <code>force</code>。</p>
<p>要限制当前工作空间内的焦点，请将 <code>focus_wrapping</code> 设置为工作空间的值。
你将需要使用 <code>focus parent</code>，直到选择工作区以使用焦点命令切换到不同的工作区（工作区命令仍将按预期工作）。</p>
<p><strong>语法：</strong></p>
<pre><code>focus_wrapping yes|no|force|workspace

# 旧语法，和 &quot;focus_wrapping force&quot; 等价
force_focus_wrapping yes
</code></pre>
<p><strong>例子：</strong></p>
<pre><code># 禁用焦点环绕
focus_wrapping no

# 强制焦点环绕
focus_wrapping force
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="强行多荧幕"><a class="header" href="#强行多荧幕">强行多荧幕</a></h1>
<p>正如 https://i3wm.org/docs/multi-monitor.html 中深入解释的那样，一些 X11 视频驱动程序（尤其是 nVidia 二进制驱动程序）仅提供对 Xinerama 的支持，而不是 RandR。在这种情况下，必须明确告知 i3 使用劣质的 Xinerama API，因此不支持动态重新配置屏幕（它们在启动时仅读取一次，仅此而已）。</p>
<p>对于无法修改 <code>~/.xsession</code> 以添加 <code>--force-xinerama</code> 命令行参数的人，提供了一个配置选项：</p>
<p><strong>语法：</strong></p>
<pre><code>force_xinerama yes|no
</code></pre>
<p><strong>例子：</strong></p>
<pre><code>force_xinerama yes
</code></pre>
<p>另请注意，使用 Xinerama 时，你的输出名称不是描述性的（如 HDMI1），而是从 0 开始计数：xinerama-0、xinerama-1……</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="当切换当前工作区时自动来回切换"><a class="header" href="#当切换当前工作区时自动来回切换">当切换当前工作区时自动来回切换</a></h1>
<p>当切换到当前聚焦的工作空间时，此配置指令启用自动 <code>workspace back_and_forth</code>（参见 <a href="https://zjuyk.site/i3wm-userguide-zh/%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8/%E5%88%87%E6%8D%A2%EF%BC%88%E5%B7%B2%E5%91%BD%E5%90%8D%EF%BC%89%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%87%B3%E6%96%B0%E5%B7%A5%E4%BD%9C%E5%8C%BA.html">back_and_forth</a>）。</p>
<p>例如：假设你在工作区“1：www”并使用 mod+2 切换到“2：IM”，因为有人向你发送了一条消息。你现在不需要记住你是从哪里切换过来的，你只需再次按 $mod+2 即可切换回“1: www”。</p>
<p><strong>语法：</strong></p>
<pre><code>workspace_auto_back_and_forth yes|no
</code></pre>
<p><strong>例子：</strong></p>
<pre><code>workspace_auto_back_and_forth yes
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="延迟工作区变化紧急提示重置"><a class="header" href="#延迟工作区变化紧急提示重置">延迟工作区变化紧急提示重置</a></h1>
<p>如果另一个工作区上的应用程序设置了紧急提示，切换到该工作区可能会导致应用程序立即获得焦点，这也意味着窗口装饰颜色将立即重置为 <code>client.focused</code>。
这可能会导致难以判断最初是哪个窗口引发了事件。</p>
<p>为了防止这种情况，你可以使用 <code>force_display_urgency_hint</code> 指令告诉 i3 延迟重置紧急状态一定时间。
将该值设置为 0 将禁用此功能。</p>
<p>默认是 500 ms.</p>
<p><strong>语法：</strong></p>
<pre><code>force_display_urgency_hint &lt;timeout&gt; ms
</code></pre>
<p><strong>例子：</strong></p>
<pre><code>force_display_urgency_hint 500 ms
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="聚焦窗口活动"><a class="header" href="#聚焦窗口活动">聚焦窗口活动</a></h1>
<p>如果一个窗口被激活，例如，通过 <code>google-chrome www.google.com</code>，它可能会请求获得焦点。
这可能不是优选的，你可以配置不同的反应。</p>
<p>请注意，这可能不会影响正在打开的窗口。要防止新窗口被聚焦，请参阅 <a href="https://zjuyk.site/i3wm-userguide-zh/%E9%85%8D%E7%BD%AEi3/%E6%89%93%E5%BC%80%E7%AA%97%E5%8F%A3%E4%B8%8D%E8%81%9A%E7%84%A6.html">no_focus</a>。</p>
<p><strong>语法：</strong></p>
<pre><code>focus_on_window_activation smart|urgent|focus|none
</code></pre>
<p>不同模式的作用如下：</p>
<p><code>smart</code></p>
<p>这是默认行为。如果请求焦点的窗口位于活动工作区上，它将获得焦点。否则，将设置紧急提示。</p>
<p><code>urgent</code></p>
<p>窗口将始终标记为紧急，但焦点不会被窃取。</p>
<p><code>focus</code></p>
<p>该窗口将始终处于焦点状态，不会被标记为紧急。</p>
<p><code>none</code></p>
<p>该窗口既不会被聚焦，也不会被标记为紧急。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="在窗口装饰绘制标记"><a class="header" href="#在窗口装饰绘制标记">在窗口装饰绘制标记</a></h1>
<p>如果激活，窗口上的标记（见 <a href="https://zjuyk.site/i3wm-userguide-zh/%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8/%E7%B1%BB%E4%BC%BCVIM%E7%9A%84%E6%A0%87%E8%AE%B0%EF%BC%88mark%E5%92%8Cgoto%EF%BC%89.html">vim_like_marks</a>）会在它们的窗口装饰中绘制。
但是，即使激活此选项，也不会绘制名称中以下划线 (_) 开头的任何标记。</p>
<p>此选项的默认值为 <code>yes</code>。</p>
<p><strong>语法：</strong></p>
<pre><code>show_marks yes|no
</code></pre>
<p><strong>例子：</strong></p>
<pre><code>show_marks yes
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="连续行"><a class="header" href="#连续行">连续行</a></h1>
<p>配置文件支持换行，这意味着当您以反斜杠字符 (<code>\</code>) 结束一行时，解析器将忽略换行符。此功能可用于创建更具可读性的配置文件。注释行无法连续。</p>
<p><strong>例子：</strong></p>
<pre><code>bindsym Mod1+f \
fullscreen toggle

# 此行不连续 \
bindsym Mod1+F fullscreen toggle
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="配置-i3bar"><a class="header" href="#配置-i3bar">配置 i3bar</a></h1>
<p>你显示器底部的条栏是由一个叫 i3bar 的独立进程绘制的。将 “i3 用户界面” 的这一部分放在一个单独的进程中，有几个好处：</p>
<ol>
<li>
<p>它是模块化的。如果你根本不需要工作区栏，或者你喜欢不同的工作区栏（dzen2、xmobar，甚至 gnome-panel？），
你可以直接删除 i3bar 的配置，然后使用你喜欢的替代品。</p>
</li>
<li>
<p>它遵循 UNIX 的理念，即 &quot;让每个程序做好一件事&quot;。i3 很擅长管理好你的每一个窗口，
i3bar 则擅长在每个显示器上显示一个栏（除非你对它进行其他配置）。</p>
</li>
<li>
<p>这使得我们可以有两个独立的、干净的代码库。如果你想了解 i3，你不需要费心去了解 i3bar 的细节，反之亦然。</p>
</li>
</ol>
<p>尽管如此，i3bar 与 i3 的配置在同一个配置文件中。这是因为它与 i3 紧密耦合（与 i3lock 或 i3status 相反，它们对使用其他窗口管理器的人很有用）。
因此，当我们已经有了一个好的配置基础结构时，在另一个地方配置是没有意义的。</p>
<p>想要配置你的工作区栏，首先需要在配置文件中创建一个叫做 <code>bar</code> 的块。
你可以有多个 <code>bar</code> 块来为不同的输出（显示器）使用不同的设置。</p>
<p><strong>例子：</strong></p>
<pre><code>bar {
    status_command i3status
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i3bar-命令"><a class="header" href="#i3bar-命令">i3bar 命令</a></h1>
<p>默认情况下，i3 会直接将 <code>i3bar</code> 传到你的 shell 来处理、搜索 <code>$PATH</code> 以找到正确的版本。如果你在某个地方有一个不同的 <code>i3bar</code> 或者二进制文件不在 <code>$PATH</code> 里，你可以告诉 i3 执行哪个文件。</p>
<p>这个特定的命令会被传到 <code>sh -c</code> 执行，因此你可以使用 globbing，且必须使用正确的引号等。</p>
<p><strong>语法：</strong></p>
<pre><code>i3bar_command &lt;command&gt;
</code></pre>
<p><strong>例子：</strong></p>
<pre><code>bar {
    i3bar_command /home/user/bin/i3bar
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="状态栏命令"><a class="header" href="#状态栏命令">状态栏命令</a></h1>
<p>i3bar 可以运行一个程序，把它的 <code>stdout</code> 的每一行显示在工作区栏的右边。这对显示系统信息很有用，比如你当前的 IP 地址、电池状态或日期/时间。</p>
<p>这个特定的命令会被传到 <code>sh -c</code> 执行，因此你可以使用 globbing，且必须使用正确的引号等。注意，对于信号处理，取决你的 shell（已知 <code>dash(1)</code> 的用户会受到影响），你必须使用 shell 的 <code>exec</code> 命令。这样信号就会传递给你的程序而不是 shell。</p>
<p><strong>语法：</strong></p>
<p><code>status_command &lt;command&gt;</code></p>
<p><strong>例子：</strong></p>
<pre><code>bar {
    status_command i3status --config ~/.i3status.conf

    # 想要信号处理正常工作的 dash(1) 用户：
    status_command exec ~/.bin/my_status_command
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="显示模式"><a class="header" href="#显示模式">显示模式</a></h1>
<p>你可以让 i3bar 在屏幕的一个边缘永久可见（<code>dock</code> 模式），或者让它在你按下修饰键时才显示出来（ <code>hide</code> 模式）。也可以强制 i3bar 始终保持隐藏状态（<code>invisible</code> 模式）。修饰键可以通过 <code>modifier</code> 选项进行配置。</p>
<p>显示模式选项可以在运行期间通过 <code>bar mode</code> 命令改变。重新加载后，它会被恢复到配置的值。</p>
<p><code>hide</code> 模式可以使屏幕空间被最大化利用，来显示实际的窗口内容。当工作区栏被隐藏时，为节省电池电量，i3bar 会向 <code>status_command</code> 进程发送 <code>SIGSTOP</code> 和 <code>SIGCONT</code> 信号。<code>status_command</code> 进程可以通过在其 JSON 头信息中设置适当的值来禁用该功能。</p>
<p><code>invisible</code> 模式允许永久地最大化屏幕空间，也就是说工作区栏永远不会显示。因此，如果你不想被打扰，可以配置即使在紧急通知或修饰键被按下时，i3bar 也不弹出来。</p>
<p>为了控制 i3bar 在 <code>hide</code> 模式下是隐藏还是显示，存在一个 <code>hidden_state</code> 选项，在 <code>dock</code> 模式或 <code>invisible</code> 模式下没有效果。它表明了当前的工作区栏的 <code>hideden_state</code>：（1）工作区栏和普通的 <code>hide</code> 模式一样是隐藏的，只有在有紧急通知或按下修饰键的情况下才会解除隐藏（<code>hide</code> 状态），或者（2）它被显示在当前可见工作区的上方（<code>show</code> 状态）。</p>
<p>和显示模式一样，<code>hidden_state</code> 也可以通过 i3 控制。可以通过使用 <code>bar hidden_state</code> 命令来实现。</p>
<p>默认的模式是 <code>dock</code> 模式；在 <code>hide</code> 模式下，默认的修饰键是 <code>Mod4</code>（通常是 windows 键）。<code>hidden_state</code> 的默认值是 <code>hide</code>。</p>
<p><strong>语法：</strong></p>
<pre><code>mode dock|hide|invisible
hidden_state hide|show
modifier &lt;Modifier&gt;|none
</code></pre>
<p><strong>例子：</strong></p>
<pre><code>bar {
    mode hide
    hidden_state hide
    modifier Mod1
}
</code></pre>
<p>可以使用的修饰符有 <code>Mod1</code> - <code>Mod5</code>，<code>Shift</code>，<code>Control</code>（详见 <code>xmodmap(1)</code>）。如果你不想要任何的修饰符触发这个行为，你也可以使用 <code>none</code> 。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="鼠标按键命令"><a class="header" href="#鼠标按键命令">鼠标按键命令</a></h1>
<p>鼠标按键在 i3bar 上被按下时运行的命令可以被指定来覆盖默认行为。这很有用，例如，用于禁用滚轮动作或运行脚本来实现自定义功能</p>
<p>一个按钮总是被命名为 <code>button&lt;n&gt;</code>，其中 1 到 7 是如下的默认按键，更高的数字是有更多按键的设备上的特殊按键。</p>
<ul>
<li>
<p>button1
鼠标左键</p>
</li>
<li>
<p>button2
鼠标中键</p>
</li>
<li>
<p>button3
鼠标右键</p>
</li>
<li>
<p>button4
滚轮向上</p>
</li>
<li>
<p>button5
滚轮向下</p>
</li>
<li>
<p>button6
滚轮向右</p>
</li>
<li>
<p>button7
滚轮向左</p>
</li>
</ul>
<p>请注意老的 <code>wheel_up_cmd</code> 和 <code>wheel_down_cmd</code> 命令已经被废弃，且会在将来的版本中被移除。我们强烈建议使用更通用的 <code>binsym</code> 配合 <code>button4</code> 和 <code>button5</code> 来替代。</p>
<p><strong>语法：</strong></p>
<pre><code>bindsym [--release] button&lt;n&gt; &lt;command&gt;
</code></pre>
<p><strong>例子：</strong></p>
<pre><code>bar {
    # 禁用点击工作区按键
    bindsym button1 nop

    # 通过右键工作区栏来截图
    bindsym --release button3 exec --no-startup-id import /tmp/latest-screenshot.png

    # 向下滚动时执行自定义脚本
    bindsym button5 exec ~/.i3/scripts/custom_wheel_down
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bar-编号"><a class="header" href="#bar-编号">Bar 编号</a></h1>
<p>为配置的工作区栏指定编号。如果缺少这个选项，ID 会被设置为 <code>bar-x</code>，其中 x 对配置文件中 <code>bar</code> 块所在的位置（<code>bar-0</code>，<code>bar-1</code>。。。）</p>
<p><strong>语法：</strong></p>
<pre><code>id &lt;bar_id&gt;
</code></pre>
<p><strong>例子：</strong></p>
<pre><code>bar {
    id bar-1
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="位置"><a class="header" href="#位置">位置</a></h1>
<p>这个选项决定了 i3bar 会被显示在屏幕的哪个边上。</p>
<p>默认是底边。</p>
<p><strong>语法：</strong></p>
<pre><code>position top|bottom
</code></pre>
<p><strong>例子：</strong></p>
<pre><code>bar {
    position top
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="输出"><a class="header" href="#输出">输出</a></h1>
<p>你可以将 i3bar 限制在一个或多个输出（显示器）。默认是处理所有的输出。如果你想要对不同的输出使用不同的选项，你可以使用多个 <code>bar</code> 块，这个时候限制输出就很有用了。</p>
<p>要使一个特定的 i3bar 实例处理多个输出，请多次使用 <code>output</code> 指令。</p>
<p>这些输出名称有特殊含义：</p>
<p><code>primary</code></p>
<p>选择在 X 服务器中被配置为主要的输出。</p>
<p><code>nonprimary</code></p>
<p>选择每一个在 X 服务器中没有被配置为主要的输出。</p>
<p><strong>语法：</strong></p>
<pre><code>output primary|nonprimary|&lt;output&gt;
</code></pre>
<p><strong>例子：</strong></p>
<pre><code># 一个大显示器显示所有内容
bar {
    # 显示器可能通过 HDMI 或者 DisplayPort 连接
    output HDMI2
    output DP2
    status_command i3status
}

# 笔记本显示器：使用亮色和 i3status，少量的模块
bar {
    output LVDS1
    status_command i3status --config ~/.i3status-small.conf
    colors {
        background #000000
        statusline #ffffff
    }
}

# 把工作区栏同时显示在主显示器和 HDMI2 上
bar {
    output primary
    output HDMI2
    status_command i3status
}
</code></pre>
<p>注意你可能没有配置主输出。想要配置，运行：</p>
<pre><code>xrandr --output &lt;output&gt; --primary
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="托盘输出"><a class="header" href="#托盘输出">托盘输出</a></h1>
<p>i3bar 默认情况下提供一个系统托盘以供类似于 NetworkManager, VLC, Pidgin 的程序可以在这里放一个小图标。</p>
<p>你可以配置这些小图标应该被显示在哪个输出上，又或者你可以把这个功能完全禁用。</p>
<p>你也可以在你的配置文件里使用多个 <code>tray_output</code> 指令来指定一系列你想要显示托盘的输出。这个列表里按顺序第一个可用输出将会被用来显示托盘。</p>
<p><strong>语法：</strong></p>
<pre><code>tray_output none|primary|&lt;output&gt;
</code></pre>
<p><strong>例子：</strong></p>
<pre><code># 禁用系统托盘
bar {
    tray_output none
}

# 在主显示器上显示托盘图标
bar {
    tray_output primary
}

# 在大显示器上显示托盘图标
bar {
    tray_output HDMI2
}
</code></pre>
<p>注意你可能没有配置主输出。想要配置，运行：</p>
<pre><code>xrandr --output &lt;output&gt; --primary
</code></pre>
<p>注意如果你有多个 bar 配置块，你要么在每个块里都指定 <code>tray_output primary</code>，要么显式地在你不想要显示托盘的 bar 块里指定 <code>tray_output none</code>。否则不同的实例为了显示图标可能会产生竞争。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="托盘内边距"><a class="header" href="#托盘内边距">托盘内边距</a></h1>
<p>托盘会显示工作区栏的右侧。默认情况下，在图标的上、右、下侧和托盘间会有一个 2 个像素的内边距。</p>
<p><strong>语法：</strong></p>
<pre><code>tray_padding &lt;px&gt; [px]
</code></pre>
<p><strong>例子：</strong></p>
<pre><code># 遵循费兹法则
tray_padding 0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字体-1"><a class="header" href="#字体-1">字体</a></h1>
<p>指定 bar 使用的自体。详见 <a href="https://zjuyk.site/i3wm-userguide-zh/%E9%85%8D%E7%BD%AEi3/%E5%AD%97%E4%BD%93.html">字体</a></p>
<p><strong>语法：</strong></p>
<pre><code>font &lt;font&gt;
</code></pre>
<p><strong>例子：</strong></p>
<pre><code>bar {
    font -misc-fixed-medium-r-normal--13-120-75-75-C-70-iso10646-1
    font pango:DejaVu Sans Mono 10
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="自定义分隔符"><a class="header" href="#自定义分隔符">自定义分隔符</a></h1>
<p>如果你不喜欢默认的一像素宽的竖直分隔符，你可以自定义一个符号作为分隔符。</p>
<p><strong>语法：</strong></p>
<pre><code>separator_symbol &lt;symbol&gt;
</code></pre>
<p><strong>例子：</strong></p>
<pre><code>bar {
    separator_symbol &quot;:|:&quot;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="工作区按钮"><a class="header" href="#工作区按钮">工作区按钮</a></h1>
<p>指定是否需要显示工作区按钮。如果你想要一个可以显示额外信息的、只有状态栏的工作区栏的话，这会很有用。</p>
<p>默认会显示工作区按钮。</p>
<p><strong>语法：</strong></p>
<pre><code>workspace_buttons yes|no
</code></pre>
<p><strong>例子：</strong></p>
<pre><code>bar {
    workspace_buttons no
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="工作区按钮最小宽度"><a class="header" href="#工作区按钮最小宽度">工作区按钮最小宽度</a></h1>
<p>默认情况下，工作区按钮的宽度是被工作区名字的宽度决定的。如果工作区的名字非常短，比如说一个字母，那工作区按钮可能会看起来太小。</p>
<p>这个选项指定了工作区按钮的最小宽度。如果工作区名太短没有办法撑满整个按钮，文本的两边会被加上额外的内边距以使文本居中。</p>
<p>默认值是 0，也就是不会加任何额外的内边距。</p>
<p>这个设置对 “绑定模式指示器” 也有效。</p>
<p>注意这里的像素指的是逻辑像素，在高分辨率屏幕下可能会被转换成更多的实际像素。</p>
<p><strong>语法：</strong></p>
<pre><code>workspace_min_width &lt;px&gt; [px]
</code></pre>
<p><strong>例子：</strong></p>
<pre><code>bar {
    workspace_min_width 40
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="去除工作区数字和名字"><a class="header" href="#去除工作区数字和名字">去除工作区数字和名字</a></h1>
<p>这个设置指定了工作区按钮是否应该显示工作区编号。如果你想要工作区可以按顺序排列，同时又不想要编号前缀的话，这个设置会很有用。</p>
<p>当 <code>strip_workspace_numbers</code> 被设置为 <code>yes</code> 时，任何的被命名为 <code>[n][:][NAME]</code> 格式的工作区只会显示名字。举个例子，你可以使用罗马数字来替代普通数字作为你的工作区名，像是 <code>1:I</code>, <code>2:II</code>, <code>3:III</code>, <code>4:IV</code>。</p>
<p>当 <code>strip_workspace_name</code> 被设置为 <code>yes</code> 时，任何的被命名为 <code>[n][:][NAME]</code> 格式的工作区只会显示编号。</p>
<p>默认情况下会在工作区按钮中显示整个名字。注意工作区名中的冒号是可选的，也就是说 <code>[n][NAME]</code> 也会被正确地去除名字和编号。</p>
<p><strong>语法：</strong></p>
<pre><code>strip_workspace_numbers yes|no
strip_workspace_name yes|no
</code></pre>
<p><strong>例子：</strong></p>
<pre><code>bar {
    strip_workspace_numbers yes
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="绑定模式指示器"><a class="header" href="#绑定模式指示器">绑定模式指示器</a></h1>
<p>指定是否显示绑定模式指示器。如果你想要隐藏工作区按钮但是仍然能够看见绑定模式指示器的话，这个选项会很有用。关于什么是模式以及如何使用，详见 <a href="https://zjuyk.site/i3wm-userguide-zh/%E9%85%8D%E7%BD%AEi3/%E7%BB%91%E5%AE%9A%E6%A8%A1%E5%BC%8F.html">绑定模式</a>。</p>
<p>默认情况下会显示绑定模式指示器。</p>
<p><strong>语法：</strong></p>
<pre><code>binding_mode_indicator yes|no
</code></pre>
<p><strong>例子：</strong></p>
<pre><code>bar {
    binding_mode_indicator no
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="颜色"><a class="header" href="#颜色">颜色</a></h1>
<p>与 i3 一样，颜色使用 HTML 的十六进制格式 (#rrggbb)。目前，这些颜色可以被设置：</p>
<p><code>background</code></p>
<p>工作区栏的背景颜色</p>
<p><code>statusline</code></p>
<p>状态栏的文字颜色</p>
<p><code>separator</code></p>
<p>分隔符的文字颜色</p>
<p><code>focused_background</code></p>
<p>当前聚焦显示器输出的工作区栏的背景颜色。如果没有被设置，这个颜色会取 <code>background</code>。</p>
<p><code>focused_statusline</code></p>
<p>当前聚焦显示器输出的状态栏的文字颜色。如果没有被设置，这个颜色会取 <code>statusline</code>。</p>
<p><code>focused_separator</code></p>
<p>当前聚焦显示器输出的分隔符的文字颜色。如果没有被设置，这个颜色会取 <code>separator</code>。</p>
<p><code>focused_workspace</code></p>
<p>聚焦工作区的按钮的边界，背景和文字颜色。</p>
<p><code>active_workspace</code></p>
<p>活跃且可见但没有被聚焦的工作区的按钮的边界、背景和文字颜色。仅当你有多个显示器时你才能区分这个和聚焦工作区的区别。</p>
<p><code>inactive_workspace</code></p>
<p>没有被聚焦，不活跃但可见的工作区的按钮的边界、背景和文字颜色。这是大部分工作区的状态。</p>
<p><code>urgent_workspace</code></p>
<p>当一个工作区中的窗口有紧急通知时的按钮的边界、背景和文字颜色。</p>
<p><code>binding_mode</code></p>
<p>绑定模式指示器的边界、背景和文字颜色。如果没有被设置，这个颜色会取 <code>urgent_workspace</code>。</p>
<p><strong>语法：</strong></p>
<pre><code>colors {
    background &lt;color&gt;
    statusline &lt;color&gt;
    separator &lt;color&gt;

    &lt;colorclass&gt; &lt;border&gt; &lt;background&gt; &lt;text&gt;
}

Example (default colors):
</code></pre>
<p><strong>例子（默认颜色）：</strong></p>
<pre><code>bar {
    colors {
        background #000000
        statusline #ffffff
        separator #666666

        focused_workspace  #4c7899 #285577 #ffffff
        active_workspace   #333333 #5f676a #ffffff
        inactive_workspace #333333 #222222 #888888
        urgent_workspace   #2f343a #900000 #ffffff
        binding_mode       #2f343a #900000 #ffffff
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="透明度"><a class="header" href="#透明度">透明度</a></h1>
<p>i3bar 支持通过在配置中使用 <code>--transparency</code> flag 来启用透明：</p>
<p><strong>语法：</strong></p>
<pre><code>bar {
    i3bar_command i3bar --transparency
}
</code></pre>
<p>在 i3bar 颜色配置和 i3bar 状态配置的颜色属性中你可以使用 RGBA 格式的颜色，也就是使用最后两位十六进制数字来指定透明度。举个例子，<code>#00000000</code> 是完全透明，而 <code>#000000FF</code> 则是完全不透明的黑色（和 <code>#000000</code> 是一样的）。</p>
<p>请注意由于托盘配置的工作方式，启用这个配置将会导致托盘图标的背景变成透明的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="命令列表"><a class="header" href="#命令列表">命令列表</a></h1>
<p>命令是你绑定在特定按键组合上的东西。你也可以通过使用 IPC 接口在运行时运行命令，而不需要按下一个键，一个简单的方法是使用 <code>i3-msg</code> 工具。</p>
<p>举例：</p>
<pre><code># 在你的 shell 中执行这个命令，去除当前的容器的边界
i3-msg border none
</code></pre>
<p>多个命令可以用 <code>;</code>（分号）连接。所以，如果想要将一个窗口移动到一个工作区中并立即切换到这个工作区，你可以配置如下的按键绑定：</p>
<pre><code>bindsym $mod+x move container to workspace 3; workspace 3
</code></pre>
<p>另外，你还可以更改命令的作用域——即哪些容器会受到该命令的影响。判断标准在命令之前用一对方括号指定，用空格隔开。</p>
<p>当作用域用于多条命令时，应使用 <code>,</code>（逗号）而不是分号来分隔它们。判断标准只适用到下一个分号之前，所以如果你使用分号来分隔命令，只有第一个命令会对被匹配的窗口执行。</p>
<p>举例：</p>
<pre><code># 如果你想杀死所有 class 是 Firefox 的窗口，使用：
bindsym $mod+x [class=&quot;Firefox&quot;] kill

# 同上，除了匹配时忽略大小写
bindsym $mod+x [class=&quot;(?i)firefox&quot;] kill

# 只杀死 Firefox 的关于对话框
bindsym $mod+x [class=&quot;Firefox&quot; window_role=&quot;About&quot;] kill

# 打开浮动模式并移动容器到工作区 4
for_window [class=&quot;^evil-app$&quot;] floating enable, move container to workspace 4

# 移动所有浮动窗口到 scratchpad
bindsym $mod+x [floating] move scratchpad
</code></pre>
<p>目前已实现的判断标准有：<span id="criteria"></span></p>
<p><strong>class</strong>:<br>
比较 window class（WM_CLASS 的第二部分）。使用特殊值 <code>__focused__</code> 匹配 window class 和目前拥有焦点的窗口相同的所有窗口。</p>
<p><strong>instance</strong>:<br>
比较 window instance（WM_CLASS 的第二部分）。使用特殊值 <code>__focused__</code> 匹配 window instance 和目前拥有焦点的窗口相同的所有窗口。</p>
<p><strong>window_role</strong>:<br>
比较 window role（WM_WINDOW_ROLE）。使用特殊值 <code>__focused__</code> 匹配 window role 和目前拥有焦点的窗口相同的所有窗口。</p>
<p><strong>window_type</strong>:<br>
比较 window type（_NET_WM_WINDOW_TYPE）。合法值有 <code>normal</code>, <code>dialog</code>, <code>utility</code>, <code>toolbar</code>, <code>splash</code>, <code>menu</code>, <code>dropdown_menu</code>, <code>popup_menu</code>, <code>tooltip</code> 和 <code>notification</code>。</p>
<p><strong>id</strong>:<br>
比较 X11 window ID，你可以使用 <code>xwininfo</code> 获得 ID。</p>
<p><strong>title</strong>:<br>
比较 X11 窗口标题（_NET_WM_NAME 或者默认值 WM_NAME）。使用特殊值 <code>__focused__</code> 匹配窗口标题和目前拥有焦点的窗口相同的所有窗口。</p>
<p><strong>urgent</strong>:<br>
比较窗口的紧急状况。值可以是 &quot;latest&quot; 或者 &quot;oldest&quot;，分别匹配最新的和最旧的紧急窗口。</p>
<p><strong>workspace</strong>:<br>
比较窗口所在工作区的名字。使用特殊值 <code>__focused__</code> 匹配目前拥有焦点的工作区中的所有窗口。</p>
<p><strong>con_mark</strong>:<br>
比较此容器的标记，见<a href="%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8/%E7%B1%BB%E4%BC%BCVIM%E7%9A%84%E6%A0%87%E8%AE%B0%EF%BC%88mark%E5%92%8Cgoto%EF%BC%89.html">类似 VIM 的标记</a>。如果一个容器的多个标记中有一个标记被匹配，这个容器就会被匹配。</p>
<p><strong>con_id</strong>:<br>
比较 i3 内部的容器 ID，你可通过 IPC 接口获得 ID。写脚本时使用它比较方便。使用特殊值 <code>__focused__</code> 匹配目前拥有焦点的那个窗口。</p>
<p><strong>floating</strong>:<br>
只匹配浮动窗口。这个判断标准没有值。</p>
<p><strong>floating_from</strong>:<br>
和 <code>floating</code> 相似但这个判断标准有两个可能的值：&quot;auto&quot; 和 &quot;user&quot;。当值是 &quot;auto&quot; 时，只有打开时就自动是浮动状态的窗口会被匹配。当值是 &quot;user&quot; 时，只有被用户改变为浮动的窗口会被匹配。</p>
<p><strong>tiling</strong>:<br>
只匹配平铺窗口。这个判断标准没有值。</p>
<p><strong>tiling_from</strong>:<br>
和 <code>tiling</code> 相似但这个判断标准有两个可能的值：&quot;auto&quot; 和 &quot;user&quot;。当值是 &quot;auto&quot; 时，只有打开时就自动是平铺状态的窗口会被匹配。当值是 &quot;user&quot; 时，只有被用户改变为平铺的窗口会被匹配。</p>
<p>判断标准 <code>class</code>, <code>instance</code>, <code>role</code>, <code>title</code>, <code>workspace</code> 和 <code>mark</code> 都是正则表达式（PCRE）。如何使用请见 <code>pcresyntax(3)</code> 或 <code>perldoc perlre</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="运行应用exec"><a class="header" href="#运行应用exec">运行应用（exec）</a></h1>
<p>如果你不能实际启动任何应用程序，那么窗口管理器有什么用呢？exec 命令通过将你指定的命令传递给 shell 来启动一个应用程序。这意味着你可以使用通配符，并将会在 <code>$PATH</code> 中搜索程序。</p>
<p>格式：</p>
<pre><code>exec [--no-startup-id] &lt;命令&gt;
</code></pre>
<p>举例：</p>
<pre><code># 打开 GIMP
bindsym $mod+g exec gimp

# 打开还不支持启动通知的终端模拟器 urxvt
bindsym $mod+Return exec --no-startup-id urxvt
</code></pre>
<p><code>--no-startup-id</code> 参数禁用了对这个 exec 命令的启动通知支持。通过使用启动通知，i3 可以确保程序的窗口在你使用 exec 命令时所在的工作区中出现。同时，它还会在应用程序启动时将 X11 光标改为 watch（一个时钟）。所以，如果一个应用程序没有支持启动通知（不过大多数使用 GTK 和 Qt 的应用程序似乎都支持），将会出现 60 秒的时钟光标。</p>
<p>如果要执行的命令包含 <code>;</code>（分号）或 <code>,</code>（逗号），那么整个命令必须被引号包裹。例如，要为 shell 命令 <code>notify-send Hello, i3</code> 设置一个绑定，你可以在你的配置文件中添加这样一个条目：</p>
<pre><code># 运行一个包含逗号的命令
bindsym $mod+p exec &quot;notify-send Hello, i3&quot;
</code></pre>
<p>如果一个带有逗号和/或分号的命令本身需要引号，你必须用双反斜线转义内部引号，像这样：</p>
<pre><code># 运行一个包含逗号、分号和引号的命令
bindsym $mod+p exec &quot;notify-send \\&quot;Hello, i3; from $USER\\&quot;&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="切分容器"><a class="header" href="#切分容器">切分容器</a></h1>
<p>split 命令使当前窗口成为一个分割容器。分割容器可以包含多个窗口。根据分割容器的布局，新的窗口会被放在当前窗口的右边（splith 横向分割），或者下面（splitv 纵向分割）。</p>
<p>如果你将这个命令应用于具有相同方向的分割容器，那么什么也不会发生。如果你应用于不同的方向，分割容器的方向将被改变（如果它没有一个以上的窗口）。如果分割容器只包含一个窗口，<code>toggle</code> 选项将切换分割容器的方向。否则，它将使当前窗口成为和父容器方向相反的分割容器。使用 <code>layout toggle split</code> 来改变分割容器的布局，从纵向分割变为横向分割或者反过来。你也可以自定义一个布局序列然后用 <code>layout toggle</code> 来在其中循环切换，见 <a href="%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8/%E6%93%8D%E7%BA%B5%E5%B8%83%E5%B1%80.html">操纵布局</a>。</p>
<p>格式：</p>
<pre><code>split vertical|horizontal|toggle
</code></pre>
<p>举例：</p>
<pre><code>bindsym $mod+v split vertical
bindsym $mod+h split horizontal
bindsym $mod+t split toggle
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="操纵布局"><a class="header" href="#操纵布局">操纵布局</a></h1>
<p>分别使用 <code>layout toggle split</code>, <code>layout stacking</code>, <code>layout tabbed</code>, <code>layout splitv</code> 或 <code>layout splith</code> 来改变当前容器的布局为横向分割/纵向分割、堆叠、标签、纵向分割或横向分割。</p>
<p>在 <code>layout toggle</code> 之后指定最多 4 个布局来在他们之间循环切换。每次执行该命令时，当前布局之后的布局将被应用。如果当前布局不在列表中，列表中的第一个布局将被激活。</p>
<p>要使当前窗口全屏，请使用 <code>fullscreen enable</code>（或全局模式的 <code>fullscreen enable global</code>)，要离开任一全屏模式，请使用 <code>fullscreen disable</code>，要在这两种状态之间切换，请使用 <code>fullscreen toggle</code>（或 <code>fullscreen toggle global</code>）。</p>
<p>同样，要使当前窗口浮动或平铺，请分别使用 <code>floating enable</code> 和 <code>floating disable</code>（或 <code>floating toggle</code>）。</p>
<p>格式：</p>
<pre><code>layout default|tabbed|stacking|splitv|splith
layout toggle [split|all]
layout toggle [split|tabbed|stacking|splitv|splith] [split|tabbed|stacking|splitv|splith]…
</code></pre>
<p>举例：</p>
<pre><code>bindsym $mod+s layout stacking
bindsym $mod+l layout toggle split
bindsym $mod+w layout tabbed

# 在堆叠/标签/分割之间切换
bindsym $mod+x layout toggle

# 在堆叠/标签/横向分割/纵向分割之间切换
bindsym $mod+x layout toggle all

# 在堆叠/标签/横向分割之间切换
bindsym $mod+x layout toggle stacking tabbed splith

# 在纵向分割/标签之间切换
bindsym $mod+x layout toggle splitv tabbed

# 在上一个分割布局/标签/堆叠之间切换
bindsym $mod+x layout toggle split tabbed stacking

# 切换全屏
bindsym $mod+f fullscreen toggle

# 切换浮动/平铺
bindsym $mod+t floating toggle
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="聚焦容器"><a class="header" href="#聚焦容器">聚焦容器</a></h1>
<p>要更改焦点，你可以使用 <code>focus</code> 命令，它有以下的选项：</p>
<p><strong>&lt;criteria&gt;</strong><br>
聚焦于满足判断标准的容器。见 <a href="%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8/%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8.html#criteria">命令标准</a>。</p>
<p><strong>left|right|up|down</strong><br>
聚焦于对应方向最近的容器。</p>
<p><strong>parent</strong><br>
聚焦于当前容器的父容器上。</p>
<p><strong>child</strong><br>
<code>focus parent</code> 的反操作。聚焦于最后一个拥有焦点的子容器。</p>
<p><strong>next|prev</strong><br>
自动聚焦到相邻的容器上。如果在命令后加上了 <code>sibling</code>，该命令将聚焦于确切的同级容器，包括非叶子容器，如分割容器。否则，它是一个在父容器的方向上的自动版本的 <code>focus left|right|up|down</code>。</p>
<p><strong>floating</strong><br>
聚焦于上一个拥有焦点的浮动容器。</p>
<p><strong>tiling</strong><br>
聚焦于上一个拥有焦点的平铺容器。</p>
<p><strong>mode_toggle</strong><br>
在浮动/平铺容器之间切换。</p>
<p><strong>output</strong><br>
加上一个方向或显示输出名称作为参数，将聚焦到对应的显示输出。</p>
<p>格式：</p>
<pre><code>&lt;criteria&gt; focus
focus left|right|down|up
focus parent|child|floating|tiling|mode_toggle
focus next|prev [sibling]
focus output left|right|up|down|primary|&lt;output&gt;
</code></pre>
<p>举例：</p>
<pre><code># 聚焦于 firefox
bindsym $mod+F1 [class=&quot;Firefox&quot;] focus

# 聚焦于左、下、上、右边的容器
bindsym $mod+j focus left
bindsym $mod+k focus down
bindsym $mod+l focus up
bindsym $mod+semicolon focus right

# 聚焦于父容器
bindsym $mod+u focus parent

# 聚焦于上一个拥有焦点的浮动/平铺容器
bindsym $mod+g focus mode_toggle

# 聚焦于右边的显示输出
bindsym $mod+x focus output right

# 聚焦于显示输出 HDMI-2
bindsym $mod+x focus output HDMI-2

# 聚焦于主显示输出
bindsym $mod+x focus output primary
</code></pre>
<p>注意，你可能还没有一个主显示输出。运行以下命令以指定一个：</p>
<pre><code class="language-sh">xrandr --output &lt;显示输出&gt; --primary
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="移动容器"><a class="header" href="#移动容器">移动容器</a></h1>
<p>使用 <code>move</code> 命令来移动一个容器。</p>
<p>格式：</p>
<pre><code># 向给定的方向移动容器。可选的 px 参数表示如果容器是浮动的，
# 它应移动多远，默认为 10 像素。可选的 ppt 参数的意思是百分
# 点（percentage points），如果使用则表示如果容器是浮动的，
# 它应移动多少百分点，而不是像素值。
move &lt;left|right|down|up&gt; [&lt;amount&gt; [px|ppt]]

# 移动容器到屏幕上指定的 (pos_x, pos_y) 坐标。
move position &lt;pos_x&gt; [px|ppt] &lt;pos_y&gt; [px|ppt]

# 移动容器到屏幕中心。如果使用了 'absolute' 参数，容器将被
# 移动到所有显示输出的中心。
move [absolute] position center

# 移动容器到当前光标的位置，只会移动浮动的容器。
move position mouse
</code></pre>
<p>举例：</p>
<pre><code># 将容器向左、下、上、右边移动
bindsym $mod+j move left
bindsym $mod+k move down
bindsym $mod+l move up
bindsym $mod+semicolon move right

# 移动容器，但让浮动容器移动多余默认值的距离
bindsym $mod+j move left 20 px

# 移动容器到所有显示输出的中心
bindsym $mod+c move absolute position center

# 移动容器到当前光标的位置
bindsym $mod+m move position mouse
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="交换容器"><a class="header" href="#交换容器">交换容器</a></h1>
<p>两个容器可以通过使用 <code>swap</code> 命令进行交换（即移动到对方的位置）。它们将继承与之互换的容器的位置和尺寸。</p>
<p>参与交换的第一个容器可以通过正常的命令判断标准过程来选择，如果没有指定标准，正在聚焦的窗口是通常的默认窗口。第二个容器可以通过以下方法之一来选择：</p>
<p><strong>id</strong><br>
窗口的 X11 窗口 ID。</p>
<p><strong>con_id</strong><br>
容器的 i3 容器 ID。</p>
<p><strong>mark</strong><br>
拥有一个标记的容器，见<a href="%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8/%E7%B1%BB%E4%BC%BCVIM%E7%9A%84%E6%A0%87%E8%AE%B0%EF%BC%88mark%E5%92%8Cgoto%EF%BC%89.html">类似 VIM 的标记</a>。</p>
<p>注意，不是所有容器都可交换。例如无法交换拥有父子关系的容器。</p>
<p>格式：</p>
<pre><code>swap container with id|con_id|mark &lt;参数&gt;
</code></pre>
<p>举例：</p>
<pre><code># 交换聚焦的容器和标记为 &quot;swapee&quot; 的容器
swap container with mark swapee

# 交换标记为 &quot;A&quot; 和 &quot;B&quot; 的容器
[con_mark=&quot;^A$&quot;] swap container with mark B
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="固定浮动窗口"><a class="header" href="#固定浮动窗口">固定浮动窗口</a></h1>
<p>如果你想让一个窗口固定在显示器上，即使你切换到另一个工作区，它还留在屏幕上，那么你可以使用 <code>sticky</code> 命令。例如，这对记事本、媒体播放器或视频聊天窗口很有用。</p>
<p>请注意，虽然任何窗口都可以通过这个命令变成固定的，但只有在窗口是浮动的情况下才会生效。</p>
<p>格式：</p>
<pre><code>sticky enable|disable|toggle
</code></pre>
<p>举例：</p>
<pre><code># 固定启动为记事本的终端
for_window [instance=notepad] sticky enable
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="切换已命名工作区和移动至新工作区"><a class="header" href="#切换已命名工作区和移动至新工作区">切换（已命名）工作区和移动至新工作区</a></h1>
<p>要切换到一个工作区，应使用 <code>workspace</code> 命令，加上工作区的编号或名字。加上可选的选项 <code>--no-auto-back-and-forth</code> 以对本次命令禁用<a href="%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8/../%E9%85%8D%E7%BD%AEi3/%E5%BD%93%E5%88%87%E6%8D%A2%E5%BD%93%E5%89%8D%E5%B7%A5%E4%BD%9C%E5%8C%BA%E6%97%B6%E8%87%AA%E5%8A%A8%E6%9D%A5%E5%9B%9E%E5%88%87%E6%8D%A2.html">自动来回切换</a>。</p>
<p>要移动容器到一个工作区，使用 <code>move container to workspace</code>。</p>
<p>你也可以通过命令 <code>workspace next</code> 和 <code>workspace prev</code> 切换到下一个和上一个工作区。例如，如果你有工作区 1、3、4 和 9，然后你想用一个组合键循环浏览它们，用这两个命令就这很方便。如果要将这些限制在当前的输出，可以使用 <code>workspace next_on_output</code> 和 <code>workspace prev_on_output</code>。同样，你可以使用 <code>move container to workspace next</code>、<code>move container to workspace prev</code> 来将一个容器移动到下一个/上一个工作区，以及 <code>move container to workspace current</code>（最后一个命令只有在与判断标准一起使用时才有意义）。</p>
<p><code>workspace next</code> 可在编号的或命名的工作区中循环。但当它到达最后一个编号的/命名的工作区时，它在遍历完编号的工作区后会寻找命名的工作区，在遍历完命名的工作区后会寻找编号的工作区。</p>
<p>对于如何移动容器/工作区到一个不同的 RandR 输出，见<a href="%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8/%E7%A7%BB%E5%8A%A8%E5%AE%B9%E5%99%A8%E6%88%96%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%88%B0RandR%E8%BE%93%E5%87%BA.html">移动容器或工作区到 RandR 输出</a>。</p>
<p>工作区的名字会以 <a href="https://developer.gnome.org/pango/stable/pango-Markup.html">Pango 标记</a> 的格式被 i3bar 解析。</p>
<p>要切换回之前聚焦的工作区，使用 <code>workspace back_and_forth</code>；类似地你可以用 <code>move container to workspace back_and_forth</code> 来将一个容器移动到之前聚焦的工作区。</p>
<p>格式：</p>
<pre><code>workspace next|prev|next_on_output|prev_on_output
workspace back_and_forth
workspace [--no-auto-back-and-forth] &lt;名字&gt;
workspace [--no-auto-back-and-forth] number &lt;名字&gt;

move [--no-auto-back-and-forth] [window|container] [to] workspace &lt;名字&gt;
move [--no-auto-back-and-forth] [window|container] [to] workspace number &lt;名字&gt;
move [window|container] [to] workspace prev|next|current
</code></pre>
<p>举例：</p>
<pre><code>bindsym $mod+1 workspace 1
bindsym $mod+2 workspace 2
bindsym $mod+3 workspace 3:&lt;span foreground=&quot;red&quot;&gt;vim&lt;/span&gt;
...

bindsym $mod+Shift+1 move container to workspace 1
bindsym $mod+Shift+2 move container to workspace 2
...

# 在当前聚焦的和上一个聚焦的工作区之间切换
bindsym $mod+b workspace back_and_forth
bindsym $mod+Shift+b move container to workspace back_and_forth

# 移动整个工作间到右边的显示输出
bindsym $mod+x move workspace to output right

# 移动 firefox 到当前工作区
bindsym $mod+F1 [class=&quot;Firefox&quot;] move workspace current
</code></pre>
<h2 id="命名的工作区"><a class="header" href="#命名的工作区">命名的工作区</a></h2>
<p>工作区用名字来标识。所以你可以可以在 workspace 命令中使用任意名字，而不只是数字：</p>
<pre><code>bindsym $mod+1 workspace mail
...
</code></pre>
<p>如果你想让工作区<strong>同时</strong>有编号和名字，你可以在名字前面添加编号，像这样：</p>
<pre><code>bindsym $mod+1 workspace 1: mail
bindsym $mod+2 workspace 2: www
...
</code></pre>
<p>注意，在这种情况下工作区将被命名为 &quot;1: mail&quot;。i3 以一种稍微特殊的方式处理以数字开头的工作区名称。通常情况下，命名的工作区是按照它们出现的顺序排序的。当它们以数字开头时，i3 将按数字排序。另外，你能用 <code>workspace number 1</code> 来切换到以数字 1 开头的工作区，而不管它的名字是什么。这在你动态改变工作区名称的情况下非常有用。要结合两个命令，你可以使用 <code>workspace number 1: mail</code> 来指定一个默认名字，如果目前没有以 &quot;1&quot; 开头的工作区的话。</p>
<h2 id="重命名工作区"><a class="header" href="#重命名工作区">重命名工作区</a></h2>
<p>你可以重命名工作区。如果你从默认的编号的工作区开始做你的工作，并在之后重命名工作区以反映它们上的实际内容，这可能是有用的。你也可以省略旧的名字来重命名当前聚焦的工作区，如果你想在 <code>i3-input</code> 中使用重命名命令，这很方便。</p>
<p>格式：</p>
<pre><code>rename workspace &lt;旧名字&gt; to &lt;新名字&gt;
rename workspace to &lt;新名字&gt;
</code></pre>
<p>举例：</p>
<pre><code>i3-msg 'rename workspace 5 to 6'
i3-msg 'rename workspace 1 to &quot;1: www&quot;'
i3-msg 'rename workspace &quot;1: www&quot; to &quot;10: www&quot;'
i3-msg 'rename workspace to &quot;2: mail&quot;'
bindsym $mod+r exec i3-input -F 'rename workspace to &quot;%s&quot;' -P 'New name: '
</code></pre>
<p>如果你想在保持切换命令稳定的同时按需重命名工作空间，你可以使用这样的设置。</p>
<pre><code>bindsym $mod+1 workspace number &quot;1: www&quot;
bindsym $mod+2 workspace number &quot;2: mail&quot;
...
</code></pre>
<p>如果工作区不存在，命令 <code>workspace number &quot;1: mail&quot;</code> 将会创建名为 &quot;1: mail&quot; 的工作区。</p>
<p>如果编号为 1 的工作区存在，此命令将切换到这个工作区并忽略名字。所以即使这个工作区被重命名为了 &quot;1: web&quot;，上面的命令仍然会切换到它。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="移动工作区到另一不同屏幕"><a class="header" href="#移动工作区到另一不同屏幕">移动工作区到另一不同屏幕</a></h1>
<p>对于如何移动容器/工作区到一个不同的 RandR 输出，见<a href="%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8/%E7%A7%BB%E5%8A%A8%E5%AE%B9%E5%99%A8%E6%88%96%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%88%B0RandR%E8%BE%93%E5%87%BA.html">移动容器或工作区到 RandR 输出</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="移动容器或工作区到-randr-输出"><a class="header" href="#移动容器或工作区到-randr-输出">移动容器或工作区到 RandR 输出</a></h1>
<p>要移动一个容器到另一个 RandR 输出（用类似 <code>LVDS1</code> 和 <code>VGA1</code> 的名字标识），或者用方向标识的 RandR 输出，有两个命令可用：</p>
<pre><code>move container to output left|right|down|up|current|primary|&lt;显示输出&gt;
move workspace to output left|right|down|up|current|primary|&lt;显示输出&gt;
</code></pre>
<p>举例：</p>
<pre><code># 移动目前工作区到下一个输出（如果你只有两个输出，相当于在两个输出之间切换）
bindsym $mod+x move workspace to output right

# 将此窗口移动到投影仪输出
bindsym $mod+x move container to output VGA1

# 将此窗口移到主输出
bindsym $mod+x move container to output primary
</code></pre>
<p>注意，你可能还没有一个主显示输出。运行以下命令以指定一个：</p>
<pre><code>xrandr --output &lt;显示输出&gt; --primary
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="移动容器和窗口到标记区"><a class="header" href="#移动容器和窗口到标记区">移动容器和窗口到标记区</a></h1>
<p>要把一个容器移到另一个有特定标记的容器上（见<a href="%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8/%E7%B1%BB%E4%BC%BCVIM%E7%9A%84%E6%A0%87%E8%AE%B0%EF%BC%88mark%E5%92%8Cgoto%EF%BC%89.html">类似 VIM 的标记</a>），你可以使用以下命令。</p>
<p>窗口将被移到树中被标记的容器之后，也就是说，它最后的位置与你在标记的容器拥有焦点时打开一个新窗口的位置相同。如果标记是在一个分割容器上，那么窗口将作为一个新的子节点出现在该容器内当前拥有焦点的子节点之后。</p>
<p>格式：</p>
<pre><code>move window|container to mark &lt;标记&gt;
</code></pre>
<p>举例：</p>
<pre><code>for_window [instance=&quot;tabme&quot;] move window to mark target
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="改变窗口和容器大小"><a class="header" href="#改变窗口和容器大小">改变窗口和容器大小</a></h1>
<p>如果要使用键盘调整容器/窗口的大小，可以使用 <code>resize</code> 命令：</p>
<p><strong>语法：</strong></p>
<pre><code>resize grow|shrink &lt;direction&gt; [&lt;px&gt; px [or &lt;ppt&gt; ppt]]
resize set [width] &lt;width&gt; [px | ppt]
resize set height &lt;height&gt; [px | ppt]
resize set [width] &lt;width&gt; [px | ppt] [height] &lt;height&gt; [px | ppt]
</code></pre>
<p>方向可以是 <code>up</code>, <code>down</code>, <code>left</code> 或 <code>right</code> 之一。或者你可以不那么具体并使用 <code>width</code> 或 <code>height</code>，在这种情况下，i3 将从所有其他容器中获取/提供空间。
可选的 pixel 参数指定容器应增大或缩小的像素数（默认值为 10 像素）。 选的 ppt 参数表示“百分比点”，如果指定，它表示平铺容器应该增长或缩小那么多点，而不是 px 值。</p>
<p>注意 <code>resize set</code>: <width> 或 <height> 的值为 0 表示“不沿此方向调整大小”。</p>
<p>建议在专用绑定模式下定义用于调整大小的绑定。有关更多上下文，请参阅 <a href="https://zjuyk.site/i3wm-userguide-zh/%E9%85%8D%E7%BD%AEi3/%E7%BB%91%E5%AE%9A%E6%A8%A1%E5%BC%8F.html">绑定模式</a> 和 i3 <a href="https://github.com/i3/i3/blob/next/etc/config.keycodes">默认配置</a>中的示例。</p>
<p><strong>例子：</strong></p>
<pre><code>for_window [class=&quot;urxvt&quot;] resize set 640 480
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="跳转到特定窗口"><a class="header" href="#跳转到特定窗口">跳转到特定窗口</a></h1>
<p>通常在多显示器环境中，你会希望快速跳转到特定窗口。例如，在工作区 3 上工作时，你可能想要跳转到邮件客户端，向你的老板发送电子邮件，告知你已经实现了一些重要目标。与其弄清楚如何导航到邮件客户端，不如使用快捷方式。你可以使用 <code>focus</code> 命令。</p>
<p><strong>语法：</strong></p>
<pre><code>[class=&quot;class&quot;] focus
[title=&quot;title&quot;] focus
</code></pre>
<p><strong>例子：</strong></p>
<pre><code># 进入下一个打开的 VIM 实例
bindsym $mod+a [class=&quot;urxvt&quot; title=&quot;VIM&quot;] focus
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类似-vim-的标记mark-和-goto"><a class="header" href="#类似-vim-的标记mark-和-goto">类似 VIM 的标记（mark 和 goto）</a></h1>
<p>此功能类似于跳转功能：它允许你直接跳转到特定窗口（这意味着切换到适当的工作区并将焦点设置到窗口）。
但是，你可以使用任意标签直接标记特定窗口，然后再使用它。
你可以使用 unmark 命令以相同的方式取消标记标签。
如果你不指定标签，取消标记将删除所有标记。
你不需要确保你的窗口具有唯一的类或标题，也不需要更改你的配置文件。</p>
<p>由于该命令需要包含要用于标记窗口的标签，因此不能简单地将其绑定到一个键。
<code>i3-input</code> 是为此目的创建的工具：它允许你输入命令并将命令发送到 i3。
它还可以为该命令添加前缀并为输入对话框显示自定义提示。</p>
<p>如果窗口已经有这个标记，附加的 <code>--toggle</code> 选项将删除该标记，否则将添加它。
请注意，你可能需要将此与 <code>--add</code>（见下文）结合使用，否则任何其他标记都将被删除。</p>
<p><code>--replace</code> 参数使 i3 删除任何现有标记，这也是默认行为。
你可以使用 <code>--add</code> 标志在窗口上放置多个标记。</p>
<p>如果你不想在窗口装饰中显示标记，请参阅 <a href="https://zjuyk.site/i3wm-userguide-zh/%E9%85%8D%E7%BD%AEi3/%E5%9C%A8%E7%AA%97%E5%8F%A3%E8%A3%85%E9%A5%B0%E7%BB%98%E5%88%B6%E6%A0%87%E8%AE%B0.html">显示标记</a>。</p>
<p><strong>语法：</strong></p>
<pre><code>mark [--add|--replace] [--toggle] &lt;identifier&gt;
[con_mark=&quot;identifier&quot;] focus
unmark &lt;identifier&gt;
</code></pre>
<p>你可以使用 <code>i3-input</code> 提示输入标记名称，然后使用 <code>mark</code> 和 <code>focus</code> 命令创建并跳转到自定义标记：</p>
<p><strong>例子：</strong></p>
<pre><code># 读取 1 个字符并用该字符标记当前窗口
bindsym $mod+m exec i3-input -F 'mark %s' -l 1 -P 'Mark: '

# 读取 1 个字符并转到带有该字符的窗口
bindsym $mod+g exec i3-input -F '[con_mark=&quot;%s&quot;] focus' -l 1 -P 'Goto: '
</code></pre>
<p>或者，如果你不想弄乱 <code>i3-input</code>，你可以为一组特定的标签创建单独的绑定，然后只使用这些标签：</p>
<p><strong>例子（在终端）：</strong></p>
<pre><code># 标记焦点容器
mark irssi

# 从任何有它的容器中删除标记“irssi”
'[con_mark=&quot;irssi&quot;] focus'

# remove the mark &quot;irssi&quot; from whichever container has it
unmark irssi

# 删除所有 firefox 窗口上的所有标记
[class=&quot;(?i)firefox&quot;] unmark
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="窗口标题格式"><a class="header" href="#窗口标题格式">窗口标题格式</a></h1>
<p>默认情况下，i3 将简单地打印 X11 窗口标题。
使用 <code>title_format</code>，可以通过将格式设置为所需的输出来自定义。
该指令支持 <a href="https://developer.gnome.org/pango/stable/pango-Markup.html">Pango markup</a> 和以下将被替换的占位符：</p>
<p><code>%title</code></p>
<p>对于普通窗口，这是 X11 窗口标题（_NET_WM_NAME 或 WM_NAME 作为后备）。当在没有窗口的容器上使用时（例如，选项卡式/堆叠布局内的拆分容器），这将是容器的树表示（例如，“H[xterm xterm]”）。</p>
<p><code>%class</code></p>
<p>X11 窗口类（WM_CLASS 的第二部分）。这对应于 <code>class</code> 标准，请参阅 <a href="%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8/%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8.html#class">命令标准</a>。</p>
<p><code>%instance</code></p>
<p>X11 窗口实例（WM_CLASS 的第一部分）。这对应于 <code>instance</code> 标准，请参阅 <a href="%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8/%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8.html#instance">命令标准</a>。</p>
<p>使用 <a href="https://zjuyk.site/i3wm-userguide-zh/%E9%85%8D%E7%BD%AEi3/%E9%92%88%E5%AF%B9%E7%AA%97%E5%8F%A3%E4%B8%93%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%88for_window%EF%BC%89.html">for_window</a> 指令，你可以根据 <a href="%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8/%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8.html#for_window">命令标准</a> 为任何窗口设置标题格式。</p>
<p><strong>语法：</strong></p>
<pre><code>title_format &lt;format&gt;
</code></pre>
<p><strong>例子：</strong></p>
<pre><code># 给焦点窗口一个前缀
bindsym $mod+p title_format &quot;Important | %title&quot;

# 以粗体打印所有窗口标题
for_window [class=&quot;.*&quot;] title_format &quot;&lt;b&gt;%title&lt;/b&gt;&quot;

# 以红色打印 Firefox 窗口的窗口标题
for_window [class=&quot;(?i)firefox&quot;] title_format &quot;&lt;span foreground='red'&gt;%title&lt;/span&gt;&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="改变边框样式"><a class="header" href="#改变边框样式">改变边框样式</a></h1>
<p>要更改当前客户端的边框，可以使用 <code>border normal</code> 使用普通边框（包括窗口标题），<code>border pixel 1</code> 使用 1 像素边框（无窗口标题）和 <code>border none</code> 使客户端无边框。</p>
<p>还有 <code>border toggle</code> 可以切换不同的边框样式。可选的像素参数可用于在切换到普通和像素样式时指定边框宽度。</p>
<p>请注意，“像素”是指逻辑像素。在 HiDPI 显示器上，一个逻辑像素由多个物理像素表示，因此 <code>pixel 1</code> 可能不一定转换为单个像素行宽边框。</p>
<p><strong>语法：</strong></p>
<pre><code>border normal|pixel|toggle [&lt;n&gt;]
border none

# 旧语法，相当于 &quot;border pixel 1&quot;
border 1pixel
</code></pre>
<p><strong>例子：</strong></p>
<pre><code># 使用窗口标题，但没有边框
bindsym $mod+t border normal 0
# 不使用窗口标题和粗边框
bindsym $mod+y border pixel 3
# 既不使用窗口标题也不使用边框
bindsym $mod+u border none
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="启用共享内存日志"><a class="header" href="#启用共享内存日志">启用共享内存日志</a></h1>
<p>如 https://i3wm.org/docs/debugging.html 中所述，i3 可以记录到共享内存缓冲区，你可以使用 <code>i3-dump-log</code> 转储该缓冲区。<code>shmlog</code> 命令允许你在运行时启用或禁用共享内存日志记录。</p>
<p>注意在使用 <code>shmlog &lt;size_in_bytes&gt;</code> 时，当前的日志会被丢弃并启动一个新的日志。</p>
<p><strong>语法：</strong></p>
<pre><code>shmlog &lt;size_in_bytes&gt;
shmlog on|off|toggle
</code></pre>
<p><strong>例子：</strong></p>
<pre><code># 启用/禁用日志记录
bindsym $mod+x shmlog toggle

# 或者，从终端：
# 将共享内存日志缓冲区增加到 50 MiB
i3-msg shmlog $((50*1024*1024))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="启用调试日志"><a class="header" href="#启用调试日志">启用调试日志</a></h1>
<p><code>debuglog</code> 命令允许你在运行时启用或禁用调试日志记录。
调试日志记录比非调试日志记录详细得多。
此命令不会激活共享内存日志记录 (shmlog)，因此很可能与上述 <a href="https://zjuyk.site/i3wm-userguide-zh/%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8/%E5%90%AF%E7%94%A8%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E6%97%A5%E5%BF%97.html">shmlog</a> 命令结合使用。</p>
<p><strong>语法：</strong></p>
<pre><code>debuglog on|off|toggle
</code></pre>
<p><strong>例子：</strong></p>
<pre><code># 启用/禁用日志记录
bindsym $mod+x debuglog toggle
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="重载重启和退出"><a class="header" href="#重载重启和退出">重载重启和退出</a></h1>
<p>你可以使用 <code>reload</code> 使 i3 重新加载其配置文件。
你还可以使用 <code>restart</code> 命令就地重新启动 i3 以使其摆脱某种奇怪的状态（如果应该发生的话）或执行升级而不必重新启动 X 会话。
要正确退出 i3，你可以使用 <code>exit</code> 命令（简单地终止您的 X 会话也可以）。</p>
<p><strong>例子：</strong></p>
<pre><code>bindsym $mod+Shift+r restart
bindsym $mod+Shift+w reload
bindsym $mod+Shift+e exit
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scratchpad"><a class="header" href="#scratchpad">Scratchpad</a></h1>
<p>有两个命令可以将任何现有窗口用作便笺窗口。<code>move scratchpad</code> 将一个窗口移动到暂存器工作区。
这将使它不可见，直到你再次显示它。你将无法打开该工作区。
相反，当使用 <code>scratchpad show</code> 时，窗口将再次显示为浮动窗口，以你当前的工作区为中心（在可见的便签簿窗口上使用 <code>scratchpad show</code> 将使其再次隐藏，因此你可以使用键绑定来切换）。
请注意，这只是一个普通的浮动窗口，因此如果你想“将其从便笺窗口中删除”，你可以简单地使其再次平铺（<code>floating toggle</code>）。</p>
<p>顾名思义，这对于拥有一个随时可用的带有你最喜欢的编辑器的窗口很有用。
但是，你也可以将它用于你不想一直看到的其他永久运行的应用程序：你的音乐播放器、alsamixer，甚至是邮件客户端……？</p>
<p>语法：</p>
<pre><code>move scratchpad

scratchpad show
</code></pre>
<p>例子：</p>
<pre><code># 使当前聚焦的窗口成为便笺簿
bindsym $mod+Shift+minus move scratchpad

# 显示第一个便笺簿窗口
bindsym $mod+minus scratchpad show

# 显示 sup-mail 暂存窗口，如果有的话。
bindsym mod4+s [title=&quot;^Sup ::&quot;] scratchpad show
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nop"><a class="header" href="#nop">Nop</a></h1>
<p>有一个无操作命令 <code>nop</code> 允许你覆盖默认行为。这对于禁用鼠标中键单击时的焦点更改很有用。</p>
<p>可选的注释参数被忽略，但会被打印到日志文件中以供调试。</p>
<p>语法：</p>
<pre><code>nop [&lt;comment&gt;]
</code></pre>
<p>例子：</p>
<pre><code># 禁用点击标题栏的焦点变化
# 使用鼠标中键
bindsym button2 nop
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i3bar-控制"><a class="header" href="#i3bar-控制">i3bar 控制</a></h1>
<p>每个 i3bar 实例的配置中有两个选项可以在运行时通过 i3 调用命令来更改。
命令 <code>bar hidden_​​state</code> 和 <code>bar mode</code> 允许分别设置每个 bar 的当前 hidden_​​state 模式选项。
还可以在隐藏状态和显示状态以及停靠模式和隐藏模式之间切换。
每个 i3bar 实例都可以通过指定 bar_id 来单独控制，如果没有给出，则对所有 bar 实例执行该命令。</p>
<p><strong>语法：</strong></p>
<pre><code>bar hidden_state hide|show|toggle [&lt;bar_id&gt;]

bar mode dock|hide|invisible|toggle [&lt;bar_id&gt;]
</code></pre>
<p><strong>例子：</strong></p>
<pre><code># 在隐藏状态和显示状态之间切换
bindsym $mod+m bar hidden_state toggle

# 在停靠模式和隐藏模式之间切换
bindsym $mod+n bar mode toggle

# 设置id为'bar-1'的bar实例切换到隐藏模式
bindsym $mod+b bar mode hide bar-1

# 将 id 为 'bar-1' 的 bar 实例设置为始终隐藏
bindsym $mod+Shift+b bar mode invisible bar-1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="多显示器"><a class="header" href="#多显示器">多显示器</a></h1>
<p>正如你在网站上的目标列表中所看到的，i3 在开发时特别考虑了对多显示器的支持。本节将解释如何处理多显示器。</p>
<p>当你只有一个显示器时，事情很简单。你通常从显示器上的工作区 1 开始，然后根据需要打开新的工作区。</p>
<p>当你有一个以上的显示器时，每个显示器将得到一个初始工作区。第一个显示器得到 1，第二个得到 2，第三个得到 3。当你切换到其它显示器上的工作区时，i3 将先切换到该显示器，然后再切换到该工作区。这样一来，你就不需要用特定的快捷键来切换到一个显示器，也不需要记住你把哪个工作区放在哪个显示器上。新的工作空间将在当前活动的显示器上打开。不会存在一个没有工作区的显示器。</p>
<p>使用全局工作区的想法是基于这样的观察：大多数用户在他们额外显示器上的工作区个数通常非常有限。它们通常被用于一个特定的任务（如浏览器、shell）或者用于监视一些东西（如邮件、IRC、系统日志……）。因此，在一个显示器上使用一个工作区，而在其他显示器上使用所有其余的工作区往往是说得通的。然而，由于你可以在 i3 中创建无限数量的工作空间，并将它们与特定的屏幕绑定，所以你可以通过改变配置（例如使用 modes）来模拟每个屏幕有几个工作空间的“传统”方式。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="配置显示器"><a class="header" href="#配置显示器">配置显示器</a></h1>
<p>如果你以前从未使用过多显示器，为了帮助你开始工作，这里有一个关于xrandr选项的简短概述，你可能会感兴趣。获取当前屏幕配置的概览总是很有用的。只要运行 &quot;xrandr&quot;，你就会得到类似的输出：</p>
<pre><code>$ xrandr
Screen 0: minimum 320 x 200, current 1280 x 800, maximum 8192 x 8192
VGA1 disconnected (normal left inverted right x axis y axis)
LVDS1 connected 1280x800+0+0 (normal left inverted right x axis y axis) 261mm x 163mm
   1280x800       60.0*+   50.0
   1024x768       85.0     75.0     70.1     60.0
   832x624        74.6
   800x600        85.1     72.2     75.0     60.3     56.2
   640x480        85.0     72.8     75.0     59.9
   720x400        85.0
   640x400        85.1
   640x350        85.1
</code></pre>
<p>这里有几件事很重要。你可以看到 <code>LVDS1</code> 被连接了（当然，它是内部显示器），但 <code>VGA1</code> 没有。如果你有一个显示器连接到了端口，但 xrandr 仍然显示 &quot;disconnected&quot;，你应该检查你的连接线、显示器或图形驱动程序。</p>
<p>你可以在第一行末尾看到的最大分辨率是显示器的最大组合分辨率。默认情况下，它通常太低，必须通过编辑 <code>/etc/X11/xorg.conf</code> 来更改。</p>
<p>下面假设你连接了 <code>VGA1</code>，想把它作为一个额外的屏幕使用：</p>
<pre><code>xrandr --output VGA1 --auto --left-of LVDS1
</code></pre>
<p>这个命令使 xrandr 尝试找到 <code>VGA1</code> 设备的原始分辨率，并将其配置在你的内部显示器的左边。当再次运行 &quot;xrandr&quot; 时，输出将看起来像这样：</p>
<pre><code>$ xrandr
Screen 0: minimum 320 x 200, current 2560 x 1024, maximum 8192 x 8192
VGA1 connected 1280x1024+0+0 (normal left inverted right x axis y axis) 338mm x 270mm
   1280x1024      60.0*+   75.0
   1280x960       60.0
   1152x864       75.0
   1024x768       75.1     70.1     60.0
   832x624        74.6
   800x600        72.2     75.0     60.3     56.2
   640x480        72.8     75.0     66.7     60.0
   720x400        70.1
LVDS1 connected 1280x800+1280+0 (normal left inverted right x axis y axis) 261mm x 163mm
   1280x800       60.0*+   50.0
   1024x768       85.0     75.0     70.1     60.0
   832x624        74.6
   800x600        85.1     72.2     75.0     60.3     56.2
   640x480        85.0     72.8     75.0     59.9
   720x400        85.0
   640x400        85.1
   640x350        85.1
</code></pre>
<p>请注意 i3 和 xrandr 使用相同的 API，所以 i3 识别的显示器和 xrandr 命令显示的一样。</p>
<p>在<a href="%E5%A4%9A%E6%98%BE%E7%A4%BA%E5%99%A8/../i3%E5%92%8C%E4%BD%A0%E7%9A%84%E5%85%B6%E4%BB%96%E8%BD%AF%E4%BB%B6/%E5%81%9A%E5%B1%95%E7%A4%BA%EF%BC%88%E5%A4%9A%E6%98%BE%E7%A4%BA%E5%99%A8%EF%BC%89.html">做展示</a>一节可以看到更多关于多显示器的配置。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="多显示器环境下的有趣设置"><a class="header" href="#多显示器环境下的有趣设置">多显示器环境下的有趣设置</a></h1>
<p>如果你有一个以上的显示器，你可能会对在 i3 中的这几项配置感兴趣：</p>
<ol>
<li>
<p>你可以指定哪个工作区应该放在哪个屏幕上。这允许你在启动时有一组不同的工作区，而不是只在第一个显示器上有一个工作区，第二个显示器有第二个，以此类推。参见<a href="%E5%A4%9A%E6%98%BE%E7%A4%BA%E5%99%A8/../%E9%85%8D%E7%BD%AEi3/%E8%87%AA%E5%8A%A8%E5%B0%86%E5%B7%A5%E4%BD%9C%E5%8C%BA%E6%94%BE%E5%88%B0%E6%8C%87%E5%AE%9A%E6%98%BE%E7%A4%BA%E5%B1%8F.html">自动将工作区放到指定显示屏</a>。</p>
</li>
<li>
<p>如果你想让某些应用程序（如 MPlayer、Firefox、……）通常在大屏幕上打开，你可以把它们分配到一个特定的工作区，见<a href="%E5%A4%9A%E6%98%BE%E7%A4%BA%E5%99%A8/../%E9%85%8D%E7%BD%AEi3/%E8%87%AA%E5%8A%A8%E5%B0%86%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%94%BE%E5%88%B0%E6%8C%87%E5%AE%9A%E5%B7%A5%E4%BD%9C%E5%8C%BA.html">自动将客户端放到指定工作区</a>。</p>
</li>
<li>
<p>如果你在许多显示器上都有许多工作区，可能就很难记住你把哪个窗口放在了哪里。因此，你可以使用类似 vim 的标记来快速切换窗口。参见<a href="%E5%A4%9A%E6%98%BE%E7%A4%BA%E5%99%A8/../%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8/%E7%B1%BB%E4%BC%BCVIM%E7%9A%84%E6%A0%87%E8%AE%B0%EF%BC%88mark%E5%92%8Cgoto%EF%BC%89.html">类似 VIM 的标记</a>。</p>
</li>
<li>
<p>关于如何在显示器之间移动现有工作区的信息，请参见<a href="%E5%A4%9A%E6%98%BE%E7%A4%BA%E5%99%A8/../%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8/%E7%A7%BB%E5%8A%A8%E5%AE%B9%E5%99%A8%E6%88%96%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%88%B0RandR%E8%BE%93%E5%87%BA.html">移动容器或工作区到 RandR 输出</a>。</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i3-和你的其他软件"><a class="header" href="#i3-和你的其他软件">i3 和你的其他软件</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="显示状态栏"><a class="header" href="#显示状态栏">显示状态栏</a></h1>
<p>在大多数的窗口管理器用户中，一个非常常见的事情是屏幕某个角落的状态行。它通常是传统桌面环境任务栏中小部件的绝佳替代品。</p>
<p>如果你还没有找到你最喜欢的方式来生成这样的状态行（自己编写的脚本，conky 等），那么推荐使用 i3status 这个工具。它是用 C 编写的，目的是使用尽可能少的系统调用来减少 CPU 从睡眠状态唤醒的时间。因为 i3status 只输出文本，所以你需要将它与其他一些工具结合起来，比如 i3bar。有关如何在 i3bar 中显示 i3status 的信息，请参阅 <a href="i3%E5%92%8C%E4%BD%A0%E7%9A%84%E5%85%B6%E4%BB%96%E8%BD%AF%E4%BB%B6/../%E9%85%8D%E7%BD%AEi3bar/%E7%8A%B6%E6%80%81%E6%A0%8F%E5%91%BD%E4%BB%A4.html">状态栏命令</a>。</p>
<p>无论你使用哪个应用程序来显示状态行，你都希望确保它使用 EWMH 提示注册为停靠窗口。i3 会将窗口定位在屏幕顶部或底部，具体取决于应用程序设置的提示。使用 i3bar，您可以配置其位置，参阅 <a href="i3%E5%92%8C%E4%BD%A0%E7%9A%84%E5%85%B6%E4%BB%96%E8%BD%AF%E4%BB%B6/../%E9%85%8D%E7%BD%AEi3bar/%E4%BD%8D%E7%BD%AE.html">i3bar 位置</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="做展示多显示器"><a class="header" href="#做展示多显示器">做展示（多显示器）</a></h1>
<p>在进行演示时，你通常希望观众看到你在屏幕上看到的内容，然后浏览一系列幻灯片（如果演示很简单）。对于更复杂的演示，你可能希望有一些只有你可以在屏幕上看到的注释，而观众只能看到幻灯片。</p>
<h2 id="例子一每个人都得到相同的输出"><a class="header" href="#例子一每个人都得到相同的输出">例子一：每个人都得到相同的输出</a></h2>
<p>这是简单的情况。你将计算机连接到视频投影仪，打开（计算机和视频投影仪）并配置 X 服务器以将计算机的内部平板克隆到视频输出：</p>
<pre><code class="language-bash">xrandr --output VGA1 --mode 1024x768 --same-as LVDS1
</code></pre>
<p>然后 i3 将使用屏幕分辨率的最低通用子集，屏幕的其余部分将保持不变（它将显示 X 背景）。因此，在我们的示例中，这将是 1024x768（我的笔记本电脑有 1280x800）。</p>
<h2 id="例子二你可以看到比你的观众更多的东西"><a class="header" href="#例子二你可以看到比你的观众更多的东西">例子二：你可以看到比你的观众更多的东西</a></h2>
<p>这个更难的情况。首先，你应该在内部平板附近的某处配置 VGA 输出，例如输出右边部分：</p>
<pre><code class="language-bash">xrandr --output VGA1 --mode 1024x768 --right-of LVDS1
</code></pre>
<p>现在，i3 将在新屏幕上放置一个新工作区（取决于您的设置），并且你将处于多显示器模式（参阅 <a href="i3%E5%92%8C%E4%BD%A0%E7%9A%84%E5%85%B6%E4%BB%96%E8%BD%AF%E4%BB%B6/../%E5%A4%9A%E6%98%BE%E7%A4%BA%E5%99%A8/%E5%A4%9A%E6%98%BE%E7%A4%BA%E5%99%A8.html">multi_monitor</a>）。</p>
<p>由于 i3 不是合成窗口管理器，因此无法同时在两个屏幕上显示一个窗口。然而，你的演示软件需要完成这项工作（即在每个屏幕上打开一个窗口）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="高分辨率hidpi"><a class="header" href="#高分辨率hidpi">高分辨率（HIDPI）</a></h1>
<p>有关如何在 Linux 桌面的各个部分启用缩放的详细信息，请参阅 <a href="https://wiki.archlinux.org/index.php/HiDPI">https://wiki.archlinux.org/index.php/HiDPI</a>。i3 会从 Xft.dpi 属性读取所需的 DPI 值。该属性默认为 96 DPI，因此要实现 200% 缩放，你需要在 <code>~/.Xresources</code> 中设置 Xft.dpi: 192。</p>
<p>如果你是刚得到新显示器的 i3 用户，请仔细确认：</p>
<ul>
<li>你在 i3 配置中使用了可缩放字体（以 &quot;pango:&quot; 开头）。</li>
<li>你正在使用支持缩放的终端模拟器。你可以暂时切换到 gnome-terminal，它以支持开箱即用的扩展而闻名，直到你弄清楚如何在你最喜欢的终端模拟器中调整字体大小。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="贡献者"><a class="header" href="#贡献者">贡献者</a></h1>
<p>以下排名不分先后：</p>
<ul>
<li><a href="https://github.com/zjuyk">zjuyk</a></li>
<li><a href="https://github.com/George-Miao">George Miao</a></li>
<li><a href="https://github.com/WhiredPlanck">WhiredPlanck</a></li>
<li><a href="https://github.com/weirane">weirane</a></li>
<li><a href="https://github.com/leedagee">leedagee</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
